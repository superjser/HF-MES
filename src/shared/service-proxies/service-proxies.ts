/* tslint:disable */
//----------------------
// <auto-generated>
//     Generated using the NSwag toolchain v11.17.14.0 (NJsonSchema v9.10.52.0 (Newtonsoft.Json v9.0.0.0)) (http://NSwag.org)
// </auto-generated>
//----------------------
// ReSharper disable InconsistentNaming

import 'rxjs/add/operator/finally';
import { mergeMap as _observableMergeMap, catchError as _observableCatch } from 'rxjs/operators';
import { Observable, from as _observableFrom, throwError as _observableThrow, of as _observableOf } from 'rxjs';
import { Injectable, Inject, Optional, InjectionToken } from '@angular/core';
import { HttpClient, HttpHeaders, HttpResponse, HttpResponseBase } from '@angular/common/http';

import * as moment from 'moment';

export const API_BASE_URL = new InjectionToken<string>('API_BASE_URL');

@Injectable()
export class AccountServiceProxy {
  private http: HttpClient;
  private baseUrl: string;
  protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

  constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
    this.http = http;
    this.baseUrl = baseUrl ? baseUrl : "";
  }

  /**
   * @input (optional)
   * @return Success
   */
  isTenantAvailable(input: IsTenantAvailableInput | null | undefined): Observable<IsTenantAvailableOutput> {
    let url_ = this.baseUrl + "/api/services/app/Account/IsTenantAvailable";
    url_ = url_.replace(/[?&]$/, "");

    const content_ = JSON.stringify(input);

    let options_ : any = {
      body: content_,
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({
        "Content-Type": "application/json",
        "Accept": "application/json"
      })
    };

    return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
      return this.processIsTenantAvailable(response_);
    })).pipe(_observableCatch((response_: any) => {
      if (response_ instanceof HttpResponseBase) {
        try {
          return this.processIsTenantAvailable(<any>response_);
        } catch (e) {
          return <Observable<IsTenantAvailableOutput>><any>_observableThrow(e);
        }
      } else
        return <Observable<IsTenantAvailableOutput>><any>_observableThrow(response_);
    }));
  }

  protected processIsTenantAvailable(response: HttpResponseBase): Observable<IsTenantAvailableOutput> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse ? response.body :
        (<any>response).error instanceof Blob ? (<any>response).error : undefined;

    let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
    if (status === 200) {
      return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
        let result200: any = null;
        let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
        result200 = resultData200 ? IsTenantAvailableOutput.fromJS(resultData200) : new IsTenantAvailableOutput();
        return _observableOf(result200);
      }));
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
        return throwException("An unexpected server error occurred.", status, _responseText, _headers);
      }));
    }
    return _observableOf<IsTenantAvailableOutput>(<any>null);
  }

  /**
   * @input (optional)
   * @return Success
   */
  register(input: RegisterInput | null | undefined): Observable<RegisterOutput> {
    let url_ = this.baseUrl + "/api/services/app/Account/Register";
    url_ = url_.replace(/[?&]$/, "");

    const content_ = JSON.stringify(input);

    let options_ : any = {
      body: content_,
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({
        "Content-Type": "application/json",
        "Accept": "application/json"
      })
    };

    return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
      return this.processRegister(response_);
    })).pipe(_observableCatch((response_: any) => {
      if (response_ instanceof HttpResponseBase) {
        try {
          return this.processRegister(<any>response_);
        } catch (e) {
          return <Observable<RegisterOutput>><any>_observableThrow(e);
        }
      } else
        return <Observable<RegisterOutput>><any>_observableThrow(response_);
    }));
  }

  protected processRegister(response: HttpResponseBase): Observable<RegisterOutput> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse ? response.body :
        (<any>response).error instanceof Blob ? (<any>response).error : undefined;

    let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
    if (status === 200) {
      return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
        let result200: any = null;
        let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
        result200 = resultData200 ? RegisterOutput.fromJS(resultData200) : new RegisterOutput();
        return _observableOf(result200);
      }));
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
        return throwException("An unexpected server error occurred.", status, _responseText, _headers);
      }));
    }
    return _observableOf<RegisterOutput>(<any>null);
  }
}

@Injectable()
export class ConfigurationServiceProxy {
  private http: HttpClient;
  private baseUrl: string;
  protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

  constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
    this.http = http;
    this.baseUrl = baseUrl ? baseUrl : "";
  }

  /**
   * @input (optional)
   * @return Success
   */
  changeUiTheme(input: ChangeUiThemeInput | null | undefined): Observable<void> {
    let url_ = this.baseUrl + "/api/services/app/Configuration/ChangeUiTheme";
    url_ = url_.replace(/[?&]$/, "");

    const content_ = JSON.stringify(input);

    let options_ : any = {
      body: content_,
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({
        "Content-Type": "application/json",
      })
    };

    return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
      return this.processChangeUiTheme(response_);
    })).pipe(_observableCatch((response_: any) => {
      if (response_ instanceof HttpResponseBase) {
        try {
          return this.processChangeUiTheme(<any>response_);
        } catch (e) {
          return <Observable<void>><any>_observableThrow(e);
        }
      } else
        return <Observable<void>><any>_observableThrow(response_);
    }));
  }

  protected processChangeUiTheme(response: HttpResponseBase): Observable<void> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse ? response.body :
        (<any>response).error instanceof Blob ? (<any>response).error : undefined;

    let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
    if (status === 200) {
      return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
        return _observableOf<void>(<any>null);
      }));
    } else if (status === 401) {
      return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
        return throwException("A server error occurred.", status, _responseText, _headers);
      }));
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
        return throwException("An unexpected server error occurred.", status, _responseText, _headers);
      }));
    }
    return _observableOf<void>(<any>null);
  }
}

@Injectable()
export class DeviceServiceProxy {
  private http: HttpClient;
  private baseUrl: string;
  protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

  constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
    this.http = http;
    this.baseUrl = baseUrl ? baseUrl : "";
  }

  /**
   * @input (optional)
   * @return Success
   */
  create(input: CreateDeviceDto | null | undefined): Observable<DeviceDto> {
    let url_ = this.baseUrl + "/api/services/app/Device/Create";
    url_ = url_.replace(/[?&]$/, "");

    const content_ = JSON.stringify(input);

    let options_ : any = {
      body: content_,
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({
        "Content-Type": "application/json",
        "Accept": "application/json"
      })
    };

    return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
      return this.processCreate(response_);
    })).pipe(_observableCatch((response_: any) => {
      if (response_ instanceof HttpResponseBase) {
        try {
          return this.processCreate(<any>response_);
        } catch (e) {
          return <Observable<DeviceDto>><any>_observableThrow(e);
        }
      } else
        return <Observable<DeviceDto>><any>_observableThrow(response_);
    }));
  }

  protected processCreate(response: HttpResponseBase): Observable<DeviceDto> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse ? response.body :
        (<any>response).error instanceof Blob ? (<any>response).error : undefined;

    let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
    if (status === 200) {
      return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
        let result200: any = null;
        let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
        result200 = resultData200 ? DeviceDto.fromJS(resultData200) : new DeviceDto();
        return _observableOf(result200);
      }));
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
        return throwException("An unexpected server error occurred.", status, _responseText, _headers);
      }));
    }
    return _observableOf<DeviceDto>(<any>null);
  }

  /**
   * @input (optional)
   * @return Success
   */
  update(input: DeviceDto | null | undefined): Observable<DeviceDto> {
    let url_ = this.baseUrl + "/api/services/app/Device/Update";
    url_ = url_.replace(/[?&]$/, "");

    const content_ = JSON.stringify(input);

    let options_ : any = {
      body: content_,
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({
        "Content-Type": "application/json",
        "Accept": "application/json"
      })
    };

    return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
      return this.processUpdate(response_);
    })).pipe(_observableCatch((response_: any) => {
      if (response_ instanceof HttpResponseBase) {
        try {
          return this.processUpdate(<any>response_);
        } catch (e) {
          return <Observable<DeviceDto>><any>_observableThrow(e);
        }
      } else
        return <Observable<DeviceDto>><any>_observableThrow(response_);
    }));
  }

  protected processUpdate(response: HttpResponseBase): Observable<DeviceDto> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse ? response.body :
        (<any>response).error instanceof Blob ? (<any>response).error : undefined;

    let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
    if (status === 200) {
      return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
        let result200: any = null;
        let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
        result200 = resultData200 ? DeviceDto.fromJS(resultData200) : new DeviceDto();
        return _observableOf(result200);
      }));
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
        return throwException("An unexpected server error occurred.", status, _responseText, _headers);
      }));
    }
    return _observableOf<DeviceDto>(<any>null);
  }

  /**
   * @id (optional)
   * @return Success
   */
  get(id: number | null | undefined): Observable<DeviceDto> {
    let url_ = this.baseUrl + "/api/services/app/Device/Get?";
    if (id !== undefined)
      url_ += "Id=" + encodeURIComponent("" + id) + "&";
    url_ = url_.replace(/[?&]$/, "");

    let options_ : any = {
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({
        "Content-Type": "application/json",
        "Accept": "application/json"
      })
    };

    return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
      return this.processGet(response_);
    })).pipe(_observableCatch((response_: any) => {
      if (response_ instanceof HttpResponseBase) {
        try {
          return this.processGet(<any>response_);
        } catch (e) {
          return <Observable<DeviceDto>><any>_observableThrow(e);
        }
      } else
        return <Observable<DeviceDto>><any>_observableThrow(response_);
    }));
  }

  protected processGet(response: HttpResponseBase): Observable<DeviceDto> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse ? response.body :
        (<any>response).error instanceof Blob ? (<any>response).error : undefined;

    let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
    if (status === 200) {
      return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
        let result200: any = null;
        let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
        result200 = resultData200 ? DeviceDto.fromJS(resultData200) : new DeviceDto();
        return _observableOf(result200);
      }));
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
        return throwException("An unexpected server error occurred.", status, _responseText, _headers);
      }));
    }
    return _observableOf<DeviceDto>(<any>null);
  }

  /**
   * @skipCount (optional)
   * @maxResultCount (optional)
   * @return Success
   */
  getAll(skipCount: number | null | undefined, maxResultCount: number | null | undefined): Observable<PagedResultDtoOfDeviceDto> {
    let url_ = this.baseUrl + "/api/services/app/Device/GetAll?";
    if (skipCount !== undefined)
      url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
    if (maxResultCount !== undefined)
      url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
    url_ = url_.replace(/[?&]$/, "");

    let options_ : any = {
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({
        "Content-Type": "application/json",
        "Accept": "application/json"
      })
    };

    return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
      return this.processGetAll(response_);
    })).pipe(_observableCatch((response_: any) => {
      if (response_ instanceof HttpResponseBase) {
        try {
          return this.processGetAll(<any>response_);
        } catch (e) {
          return <Observable<PagedResultDtoOfDeviceDto>><any>_observableThrow(e);
        }
      } else
        return <Observable<PagedResultDtoOfDeviceDto>><any>_observableThrow(response_);
    }));
  }

  protected processGetAll(response: HttpResponseBase): Observable<PagedResultDtoOfDeviceDto> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse ? response.body :
        (<any>response).error instanceof Blob ? (<any>response).error : undefined;

    let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
    if (status === 200) {
      return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
        let result200: any = null;
        let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
        result200 = resultData200 ? PagedResultDtoOfDeviceDto.fromJS(resultData200) : new PagedResultDtoOfDeviceDto();
        return _observableOf(result200);
      }));
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
        return throwException("An unexpected server error occurred.", status, _responseText, _headers);
      }));
    }
    return _observableOf<PagedResultDtoOfDeviceDto>(<any>null);
  }

  /**
   * @id (optional)
   * @return Success
   */
  delete(id: number | null | undefined): Observable<void> {
    let url_ = this.baseUrl + "/api/services/app/Device/Delete?";
    if (id !== undefined)
      url_ += "Id=" + encodeURIComponent("" + id) + "&";
    url_ = url_.replace(/[?&]$/, "");

    let options_ : any = {
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({
        "Content-Type": "application/json",
      })
    };

    return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
      return this.processDelete(response_);
    })).pipe(_observableCatch((response_: any) => {
      if (response_ instanceof HttpResponseBase) {
        try {
          return this.processDelete(<any>response_);
        } catch (e) {
          return <Observable<void>><any>_observableThrow(e);
        }
      } else
        return <Observable<void>><any>_observableThrow(response_);
    }));
  }

  protected processDelete(response: HttpResponseBase): Observable<void> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse ? response.body :
        (<any>response).error instanceof Blob ? (<any>response).error : undefined;

    let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
    if (status === 200) {
      return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
        return _observableOf<void>(<any>null);
      }));
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
        return throwException("An unexpected server error occurred.", status, _responseText, _headers);
      }));
    }
    return _observableOf<void>(<any>null);
  }
}

@Injectable()
export class DeviceDataItemServiceProxy {
  private http: HttpClient;
  private baseUrl: string;
  protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

  constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
    this.http = http;
    this.baseUrl = baseUrl ? baseUrl : "";
  }

  /**
   * @input (optional)
   * @return Success
   */
  create(input: CreateDeviceDataItemDto | null | undefined): Observable<DeviceDataItemDto> {
    let url_ = this.baseUrl + "/api/services/app/DeviceDataItem/Create";
    url_ = url_.replace(/[?&]$/, "");

    const content_ = JSON.stringify(input);

    let options_ : any = {
      body: content_,
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({
        "Content-Type": "application/json",
        "Accept": "application/json"
      })
    };

    return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
      return this.processCreate(response_);
    })).pipe(_observableCatch((response_: any) => {
      if (response_ instanceof HttpResponseBase) {
        try {
          return this.processCreate(<any>response_);
        } catch (e) {
          return <Observable<DeviceDataItemDto>><any>_observableThrow(e);
        }
      } else
        return <Observable<DeviceDataItemDto>><any>_observableThrow(response_);
    }));
  }

  protected processCreate(response: HttpResponseBase): Observable<DeviceDataItemDto> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse ? response.body :
        (<any>response).error instanceof Blob ? (<any>response).error : undefined;

    let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
    if (status === 200) {
      return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
        let result200: any = null;
        let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
        result200 = resultData200 ? DeviceDataItemDto.fromJS(resultData200) : new DeviceDataItemDto();
        return _observableOf(result200);
      }));
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
        return throwException("An unexpected server error occurred.", status, _responseText, _headers);
      }));
    }
    return _observableOf<DeviceDataItemDto>(<any>null);
  }

  /**
   * @input (optional)
   * @return Success
   */
  update(input: DeviceDataItemDto | null | undefined): Observable<DeviceDataItemDto> {
    let url_ = this.baseUrl + "/api/services/app/DeviceDataItem/Update";
    url_ = url_.replace(/[?&]$/, "");

    const content_ = JSON.stringify(input);

    let options_ : any = {
      body: content_,
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({
        "Content-Type": "application/json",
        "Accept": "application/json"
      })
    };

    return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
      return this.processUpdate(response_);
    })).pipe(_observableCatch((response_: any) => {
      if (response_ instanceof HttpResponseBase) {
        try {
          return this.processUpdate(<any>response_);
        } catch (e) {
          return <Observable<DeviceDataItemDto>><any>_observableThrow(e);
        }
      } else
        return <Observable<DeviceDataItemDto>><any>_observableThrow(response_);
    }));
  }

  protected processUpdate(response: HttpResponseBase): Observable<DeviceDataItemDto> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse ? response.body :
        (<any>response).error instanceof Blob ? (<any>response).error : undefined;

    let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
    if (status === 200) {
      return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
        let result200: any = null;
        let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
        result200 = resultData200 ? DeviceDataItemDto.fromJS(resultData200) : new DeviceDataItemDto();
        return _observableOf(result200);
      }));
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
        return throwException("An unexpected server error occurred.", status, _responseText, _headers);
      }));
    }
    return _observableOf<DeviceDataItemDto>(<any>null);
  }

  /**
   * @id (optional)
   * @return Success
   */
  get(id: number | null | undefined): Observable<DeviceDataItemDto> {
    let url_ = this.baseUrl + "/api/services/app/DeviceDataItem/Get?";
    if (id !== undefined)
      url_ += "Id=" + encodeURIComponent("" + id) + "&";
    url_ = url_.replace(/[?&]$/, "");

    let options_ : any = {
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({
        "Content-Type": "application/json",
        "Accept": "application/json"
      })
    };

    return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
      return this.processGet(response_);
    })).pipe(_observableCatch((response_: any) => {
      if (response_ instanceof HttpResponseBase) {
        try {
          return this.processGet(<any>response_);
        } catch (e) {
          return <Observable<DeviceDataItemDto>><any>_observableThrow(e);
        }
      } else
        return <Observable<DeviceDataItemDto>><any>_observableThrow(response_);
    }));
  }

  protected processGet(response: HttpResponseBase): Observable<DeviceDataItemDto> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse ? response.body :
        (<any>response).error instanceof Blob ? (<any>response).error : undefined;

    let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
    if (status === 200) {
      return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
        let result200: any = null;
        let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
        result200 = resultData200 ? DeviceDataItemDto.fromJS(resultData200) : new DeviceDataItemDto();
        return _observableOf(result200);
      }));
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
        return throwException("An unexpected server error occurred.", status, _responseText, _headers);
      }));
    }
    return _observableOf<DeviceDataItemDto>(<any>null);
  }

  /**
   * @skipCount (optional)
   * @maxResultCount (optional)
   * @return Success
   */
  getAll(skipCount: number | null | undefined, maxResultCount: number | null | undefined): Observable<PagedResultDtoOfDeviceDataItemDto> {
    let url_ = this.baseUrl + "/api/services/app/DeviceDataItem/GetAll?";
    if (skipCount !== undefined)
      url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
    if (maxResultCount !== undefined)
      url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
    url_ = url_.replace(/[?&]$/, "");

    let options_ : any = {
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({
        "Content-Type": "application/json",
        "Accept": "application/json"
      })
    };

    return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
      return this.processGetAll(response_);
    })).pipe(_observableCatch((response_: any) => {
      if (response_ instanceof HttpResponseBase) {
        try {
          return this.processGetAll(<any>response_);
        } catch (e) {
          return <Observable<PagedResultDtoOfDeviceDataItemDto>><any>_observableThrow(e);
        }
      } else
        return <Observable<PagedResultDtoOfDeviceDataItemDto>><any>_observableThrow(response_);
    }));
  }

  protected processGetAll(response: HttpResponseBase): Observable<PagedResultDtoOfDeviceDataItemDto> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse ? response.body :
        (<any>response).error instanceof Blob ? (<any>response).error : undefined;

    let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
    if (status === 200) {
      return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
        let result200: any = null;
        let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
        result200 = resultData200 ? PagedResultDtoOfDeviceDataItemDto.fromJS(resultData200) : new PagedResultDtoOfDeviceDataItemDto();
        return _observableOf(result200);
      }));
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
        return throwException("An unexpected server error occurred.", status, _responseText, _headers);
      }));
    }
    return _observableOf<PagedResultDtoOfDeviceDataItemDto>(<any>null);
  }

  /**
   * @id (optional)
   * @return Success
   */
  delete(id: number | null | undefined): Observable<void> {
    let url_ = this.baseUrl + "/api/services/app/DeviceDataItem/Delete?";
    if (id !== undefined)
      url_ += "Id=" + encodeURIComponent("" + id) + "&";
    url_ = url_.replace(/[?&]$/, "");

    let options_ : any = {
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({
        "Content-Type": "application/json",
      })
    };

    return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
      return this.processDelete(response_);
    })).pipe(_observableCatch((response_: any) => {
      if (response_ instanceof HttpResponseBase) {
        try {
          return this.processDelete(<any>response_);
        } catch (e) {
          return <Observable<void>><any>_observableThrow(e);
        }
      } else
        return <Observable<void>><any>_observableThrow(response_);
    }));
  }

  protected processDelete(response: HttpResponseBase): Observable<void> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse ? response.body :
        (<any>response).error instanceof Blob ? (<any>response).error : undefined;

    let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
    if (status === 200) {
      return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
        return _observableOf<void>(<any>null);
      }));
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
        return throwException("An unexpected server error occurred.", status, _responseText, _headers);
      }));
    }
    return _observableOf<void>(<any>null);
  }
}

@Injectable()
export class DeviceDataSourceServiceProxy {
  private http: HttpClient;
  private baseUrl: string;
  protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

  constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
    this.http = http;
    this.baseUrl = baseUrl ? baseUrl : "";
  }

  /**
   * @id (optional)
   * @return Success
   */
  get(id: number | null | undefined): Observable<DeviceDataSourceDto> {
    let url_ = this.baseUrl + "/api/services/app/DeviceDataSource/Get?";
    if (id !== undefined)
      url_ += "Id=" + encodeURIComponent("" + id) + "&";
    url_ = url_.replace(/[?&]$/, "");

    let options_ : any = {
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({
        "Content-Type": "application/json",
        "Accept": "application/json"
      })
    };

    return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
      return this.processGet(response_);
    })).pipe(_observableCatch((response_: any) => {
      if (response_ instanceof HttpResponseBase) {
        try {
          return this.processGet(<any>response_);
        } catch (e) {
          return <Observable<DeviceDataSourceDto>><any>_observableThrow(e);
        }
      } else
        return <Observable<DeviceDataSourceDto>><any>_observableThrow(response_);
    }));
  }

  protected processGet(response: HttpResponseBase): Observable<DeviceDataSourceDto> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse ? response.body :
        (<any>response).error instanceof Blob ? (<any>response).error : undefined;

    let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
    if (status === 200) {
      return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
        let result200: any = null;
        let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
        result200 = resultData200 ? DeviceDataSourceDto.fromJS(resultData200) : new DeviceDataSourceDto();
        return _observableOf(result200);
      }));
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
        return throwException("An unexpected server error occurred.", status, _responseText, _headers);
      }));
    }
    return _observableOf<DeviceDataSourceDto>(<any>null);
  }

  /**
   * @skipCount (optional)
   * @maxResultCount (optional)
   * @return Success
   */
  getAll(skipCount: number | null | undefined, maxResultCount: number | null | undefined): Observable<PagedResultDtoOfDeviceDataSourceDto> {
    let url_ = this.baseUrl + "/api/services/app/DeviceDataSource/GetAll?";
    if (skipCount !== undefined)
      url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
    if (maxResultCount !== undefined)
      url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
    url_ = url_.replace(/[?&]$/, "");

    let options_ : any = {
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({
        "Content-Type": "application/json",
        "Accept": "application/json"
      })
    };

    return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
      return this.processGetAll(response_);
    })).pipe(_observableCatch((response_: any) => {
      if (response_ instanceof HttpResponseBase) {
        try {
          return this.processGetAll(<any>response_);
        } catch (e) {
          return <Observable<PagedResultDtoOfDeviceDataSourceDto>><any>_observableThrow(e);
        }
      } else
        return <Observable<PagedResultDtoOfDeviceDataSourceDto>><any>_observableThrow(response_);
    }));
  }

  protected processGetAll(response: HttpResponseBase): Observable<PagedResultDtoOfDeviceDataSourceDto> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse ? response.body :
        (<any>response).error instanceof Blob ? (<any>response).error : undefined;

    let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
    if (status === 200) {
      return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
        let result200: any = null;
        let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
        result200 = resultData200 ? PagedResultDtoOfDeviceDataSourceDto.fromJS(resultData200) : new PagedResultDtoOfDeviceDataSourceDto();
        return _observableOf(result200);
      }));
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
        return throwException("An unexpected server error occurred.", status, _responseText, _headers);
      }));
    }
    return _observableOf<PagedResultDtoOfDeviceDataSourceDto>(<any>null);
  }

  /**
   * @input (optional)
   * @return Success
   */
  create(input: CreateDeviceDataSourceDto | null | undefined): Observable<DeviceDataSourceDto> {
    let url_ = this.baseUrl + "/api/services/app/DeviceDataSource/Create";
    url_ = url_.replace(/[?&]$/, "");

    const content_ = JSON.stringify(input);

    let options_ : any = {
      body: content_,
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({
        "Content-Type": "application/json",
        "Accept": "application/json"
      })
    };

    return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
      return this.processCreate(response_);
    })).pipe(_observableCatch((response_: any) => {
      if (response_ instanceof HttpResponseBase) {
        try {
          return this.processCreate(<any>response_);
        } catch (e) {
          return <Observable<DeviceDataSourceDto>><any>_observableThrow(e);
        }
      } else
        return <Observable<DeviceDataSourceDto>><any>_observableThrow(response_);
    }));
  }

  protected processCreate(response: HttpResponseBase): Observable<DeviceDataSourceDto> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse ? response.body :
        (<any>response).error instanceof Blob ? (<any>response).error : undefined;

    let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
    if (status === 200) {
      return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
        let result200: any = null;
        let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
        result200 = resultData200 ? DeviceDataSourceDto.fromJS(resultData200) : new DeviceDataSourceDto();
        return _observableOf(result200);
      }));
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
        return throwException("An unexpected server error occurred.", status, _responseText, _headers);
      }));
    }
    return _observableOf<DeviceDataSourceDto>(<any>null);
  }

  /**
   * @input (optional)
   * @return Success
   */
  update(input: DeviceDataSourceDto | null | undefined): Observable<DeviceDataSourceDto> {
    let url_ = this.baseUrl + "/api/services/app/DeviceDataSource/Update";
    url_ = url_.replace(/[?&]$/, "");

    const content_ = JSON.stringify(input);

    let options_ : any = {
      body: content_,
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({
        "Content-Type": "application/json",
        "Accept": "application/json"
      })
    };

    return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
      return this.processUpdate(response_);
    })).pipe(_observableCatch((response_: any) => {
      if (response_ instanceof HttpResponseBase) {
        try {
          return this.processUpdate(<any>response_);
        } catch (e) {
          return <Observable<DeviceDataSourceDto>><any>_observableThrow(e);
        }
      } else
        return <Observable<DeviceDataSourceDto>><any>_observableThrow(response_);
    }));
  }

  protected processUpdate(response: HttpResponseBase): Observable<DeviceDataSourceDto> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse ? response.body :
        (<any>response).error instanceof Blob ? (<any>response).error : undefined;

    let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
    if (status === 200) {
      return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
        let result200: any = null;
        let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
        result200 = resultData200 ? DeviceDataSourceDto.fromJS(resultData200) : new DeviceDataSourceDto();
        return _observableOf(result200);
      }));
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
        return throwException("An unexpected server error occurred.", status, _responseText, _headers);
      }));
    }
    return _observableOf<DeviceDataSourceDto>(<any>null);
  }

  /**
   * @id (optional)
   * @return Success
   */
  delete(id: number | null | undefined): Observable<void> {
    let url_ = this.baseUrl + "/api/services/app/DeviceDataSource/Delete?";
    if (id !== undefined)
      url_ += "Id=" + encodeURIComponent("" + id) + "&";
    url_ = url_.replace(/[?&]$/, "");

    let options_ : any = {
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({
        "Content-Type": "application/json",
      })
    };

    return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
      return this.processDelete(response_);
    })).pipe(_observableCatch((response_: any) => {
      if (response_ instanceof HttpResponseBase) {
        try {
          return this.processDelete(<any>response_);
        } catch (e) {
          return <Observable<void>><any>_observableThrow(e);
        }
      } else
        return <Observable<void>><any>_observableThrow(response_);
    }));
  }

  protected processDelete(response: HttpResponseBase): Observable<void> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse ? response.body :
        (<any>response).error instanceof Blob ? (<any>response).error : undefined;

    let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
    if (status === 200) {
      return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
        return _observableOf<void>(<any>null);
      }));
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
        return throwException("An unexpected server error occurred.", status, _responseText, _headers);
      }));
    }
    return _observableOf<void>(<any>null);
  }
}

@Injectable()
export class DeviceDataValueServiceProxy {
  private http: HttpClient;
  private baseUrl: string;
  protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

  constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
    this.http = http;
    this.baseUrl = baseUrl ? baseUrl : "";
  }

  /**
   * @input (optional)
   * @return Success
   */
  create(input: CreateDeviceDataValueDto | null | undefined): Observable<DeviceDataValueDto> {
    let url_ = this.baseUrl + "/api/services/app/DeviceDataValue/Create";
    url_ = url_.replace(/[?&]$/, "");

    const content_ = JSON.stringify(input);

    let options_ : any = {
      body: content_,
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({
        "Content-Type": "application/json",
        "Accept": "application/json"
      })
    };

    return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
      return this.processCreate(response_);
    })).pipe(_observableCatch((response_: any) => {
      if (response_ instanceof HttpResponseBase) {
        try {
          return this.processCreate(<any>response_);
        } catch (e) {
          return <Observable<DeviceDataValueDto>><any>_observableThrow(e);
        }
      } else
        return <Observable<DeviceDataValueDto>><any>_observableThrow(response_);
    }));
  }

  protected processCreate(response: HttpResponseBase): Observable<DeviceDataValueDto> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse ? response.body :
        (<any>response).error instanceof Blob ? (<any>response).error : undefined;

    let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
    if (status === 200) {
      return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
        let result200: any = null;
        let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
        result200 = resultData200 ? DeviceDataValueDto.fromJS(resultData200) : new DeviceDataValueDto();
        return _observableOf(result200);
      }));
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
        return throwException("An unexpected server error occurred.", status, _responseText, _headers);
      }));
    }
    return _observableOf<DeviceDataValueDto>(<any>null);
  }

  /**
   * @input (optional)
   * @return Success
   */
  update(input: DeviceDataValueDto | null | undefined): Observable<DeviceDataValueDto> {
    let url_ = this.baseUrl + "/api/services/app/DeviceDataValue/Update";
    url_ = url_.replace(/[?&]$/, "");

    const content_ = JSON.stringify(input);

    let options_ : any = {
      body: content_,
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({
        "Content-Type": "application/json",
        "Accept": "application/json"
      })
    };

    return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
      return this.processUpdate(response_);
    })).pipe(_observableCatch((response_: any) => {
      if (response_ instanceof HttpResponseBase) {
        try {
          return this.processUpdate(<any>response_);
        } catch (e) {
          return <Observable<DeviceDataValueDto>><any>_observableThrow(e);
        }
      } else
        return <Observable<DeviceDataValueDto>><any>_observableThrow(response_);
    }));
  }

  protected processUpdate(response: HttpResponseBase): Observable<DeviceDataValueDto> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse ? response.body :
        (<any>response).error instanceof Blob ? (<any>response).error : undefined;

    let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
    if (status === 200) {
      return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
        let result200: any = null;
        let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
        result200 = resultData200 ? DeviceDataValueDto.fromJS(resultData200) : new DeviceDataValueDto();
        return _observableOf(result200);
      }));
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
        return throwException("An unexpected server error occurred.", status, _responseText, _headers);
      }));
    }
    return _observableOf<DeviceDataValueDto>(<any>null);
  }

  /**
   * @return Success
   */
  getDeviceDataValue(): Observable<DeviceDataValueDto[]> {
    let url_ = this.baseUrl + "/api/services/app/DeviceDataValue/GetDeviceDataValue";
    url_ = url_.replace(/[?&]$/, "");

    let options_ : any = {
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({
        "Content-Type": "application/json",
        "Accept": "application/json"
      })
    };

    return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
      return this.processGetDeviceDataValue(response_);
    })).pipe(_observableCatch((response_: any) => {
      if (response_ instanceof HttpResponseBase) {
        try {
          return this.processGetDeviceDataValue(<any>response_);
        } catch (e) {
          return <Observable<DeviceDataValueDto[]>><any>_observableThrow(e);
        }
      } else
        return <Observable<DeviceDataValueDto[]>><any>_observableThrow(response_);
    }));
  }

  protected processGetDeviceDataValue(response: HttpResponseBase): Observable<DeviceDataValueDto[]> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse ? response.body :
        (<any>response).error instanceof Blob ? (<any>response).error : undefined;

    let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
    if (status === 200) {
      return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
        let result200: any = null;
        let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
        if (resultData200 && resultData200.constructor === Array) {
          result200 = [];
          for (let item of resultData200)
            result200.push(DeviceDataValueDto.fromJS(item));
        }
        return _observableOf(result200);
      }));
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
        return throwException("An unexpected server error occurred.", status, _responseText, _headers);
      }));
    }
    return _observableOf<DeviceDataValueDto[]>(<any>null);
  }

  /**
   * @return Success
   */
  getDeviceInfoAndData(): Observable<DeviceInfoAndDataDto[]> {
    let url_ = this.baseUrl + "/api/services/app/DeviceDataValue/GetDeviceInfoAndData";
    url_ = url_.replace(/[?&]$/, "");

    let options_ : any = {
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({
        "Content-Type": "application/json",
        "Accept": "application/json"
      })
    };

    return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
      return this.processGetDeviceInfoAndData(response_);
    })).pipe(_observableCatch((response_: any) => {
      if (response_ instanceof HttpResponseBase) {
        try {
          return this.processGetDeviceInfoAndData(<any>response_);
        } catch (e) {
          return <Observable<DeviceInfoAndDataDto[]>><any>_observableThrow(e);
        }
      } else
        return <Observable<DeviceInfoAndDataDto[]>><any>_observableThrow(response_);
    }));
  }

  protected processGetDeviceInfoAndData(response: HttpResponseBase): Observable<DeviceInfoAndDataDto[]> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse ? response.body :
        (<any>response).error instanceof Blob ? (<any>response).error : undefined;

    let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
    if (status === 200) {
      return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
        let result200: any = null;
        let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
        if (resultData200 && resultData200.constructor === Array) {
          result200 = [];
          for (let item of resultData200)
            result200.push(DeviceInfoAndDataDto.fromJS(item));
        }
        return _observableOf(result200);
      }));
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
        return throwException("An unexpected server error occurred.", status, _responseText, _headers);
      }));
    }
    return _observableOf<DeviceInfoAndDataDto[]>(<any>null);
  }

  /**
   * @return Success
   */
  getYaJiPinLvs(): Observable<YaJiPinLvDto[]> {
    let url_ = this.baseUrl + "/api/services/app/DeviceDataValue/GetYaJiPinLvs";
    url_ = url_.replace(/[?&]$/, "");

    let options_ : any = {
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({
        "Content-Type": "application/json",
        "Accept": "application/json"
      })
    };

    return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
      return this.processGetYaJiPinLvs(response_);
    })).pipe(_observableCatch((response_: any) => {
      if (response_ instanceof HttpResponseBase) {
        try {
          return this.processGetYaJiPinLvs(<any>response_);
        } catch (e) {
          return <Observable<YaJiPinLvDto[]>><any>_observableThrow(e);
        }
      } else
        return <Observable<YaJiPinLvDto[]>><any>_observableThrow(response_);
    }));
  }

  protected processGetYaJiPinLvs(response: HttpResponseBase): Observable<YaJiPinLvDto[]> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse ? response.body :
        (<any>response).error instanceof Blob ? (<any>response).error : undefined;

    let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
    if (status === 200) {
      return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
        let result200: any = null;
        let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
        if (resultData200 && resultData200.constructor === Array) {
          result200 = [];
          for (let item of resultData200)
            result200.push(YaJiPinLvDto.fromJS(item));
        }
        return _observableOf(result200);
      }));
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
        return throwException("An unexpected server error occurred.", status, _responseText, _headers);
      }));
    }
    return _observableOf<YaJiPinLvDto[]>(<any>null);
  }

  /**
   * @productionLineID (optional)
   * @return Success
   */
  getYaJiPinLv(productionLineID: number | null | undefined): Observable<YaJiPinLvDto> {
    let url_ = this.baseUrl + "/api/services/app/DeviceDataValue/GetYaJiPinLv?";
    if (productionLineID !== undefined)
      url_ += "productionLineID=" + encodeURIComponent("" + productionLineID) + "&";
    url_ = url_.replace(/[?&]$/, "");

    let options_ : any = {
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({
        "Content-Type": "application/json",
        "Accept": "application/json"
      })
    };

    return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
      return this.processGetYaJiPinLv(response_);
    })).pipe(_observableCatch((response_: any) => {
      if (response_ instanceof HttpResponseBase) {
        try {
          return this.processGetYaJiPinLv(<any>response_);
        } catch (e) {
          return <Observable<YaJiPinLvDto>><any>_observableThrow(e);
        }
      } else
        return <Observable<YaJiPinLvDto>><any>_observableThrow(response_);
    }));
  }

  protected processGetYaJiPinLv(response: HttpResponseBase): Observable<YaJiPinLvDto> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse ? response.body :
        (<any>response).error instanceof Blob ? (<any>response).error : undefined;

    let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
    if (status === 200) {
      return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
        let result200: any = null;
        let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
        result200 = resultData200 ? YaJiPinLvDto.fromJS(resultData200) : new YaJiPinLvDto();
        return _observableOf(result200);
      }));
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
        return throwException("An unexpected server error occurred.", status, _responseText, _headers);
      }));
    }
    return _observableOf<YaJiPinLvDto>(<any>null);
  }

  /**
   * @deviceItemDeviceID (optional)
   * @productionLineDeviceID (optional)
   * @return Success
   */
  getKeyParamValue(deviceItemDeviceID: number | null | undefined, productionLineDeviceID: number | null | undefined): Observable<KeyParamValueDto> {
    let url_ = this.baseUrl + "/api/services/app/DeviceDataValue/GetKeyParamValue?";
    if (deviceItemDeviceID !== undefined)
      url_ += "deviceItemDeviceID=" + encodeURIComponent("" + deviceItemDeviceID) + "&";
    if (productionLineDeviceID !== undefined)
      url_ += "productionLineDeviceID=" + encodeURIComponent("" + productionLineDeviceID) + "&";
    url_ = url_.replace(/[?&]$/, "");

    let options_ : any = {
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({
        "Content-Type": "application/json",
        "Accept": "application/json"
      })
    };

    return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
      return this.processGetKeyParamValue(response_);
    })).pipe(_observableCatch((response_: any) => {
      if (response_ instanceof HttpResponseBase) {
        try {
          return this.processGetKeyParamValue(<any>response_);
        } catch (e) {
          return <Observable<KeyParamValueDto>><any>_observableThrow(e);
        }
      } else
        return <Observable<KeyParamValueDto>><any>_observableThrow(response_);
    }));
  }

  protected processGetKeyParamValue(response: HttpResponseBase): Observable<KeyParamValueDto> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse ? response.body :
        (<any>response).error instanceof Blob ? (<any>response).error : undefined;

    let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
    if (status === 200) {
      return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
        let result200: any = null;
        let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
        result200 = resultData200 ? KeyParamValueDto.fromJS(resultData200) : new KeyParamValueDto();
        return _observableOf(result200);
      }));
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
        return throwException("An unexpected server error occurred.", status, _responseText, _headers);
      }));
    }
    return _observableOf<KeyParamValueDto>(<any>null);
  }

  /**
   * @id (optional)
   * @return Success
   */
  get(id: string | null | undefined): Observable<DeviceDataValueDto> {
    let url_ = this.baseUrl + "/api/services/app/DeviceDataValue/Get?";
    if (id !== undefined)
      url_ += "Id=" + encodeURIComponent("" + id) + "&";
    url_ = url_.replace(/[?&]$/, "");

    let options_ : any = {
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({
        "Content-Type": "application/json",
        "Accept": "application/json"
      })
    };

    return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
      return this.processGet(response_);
    })).pipe(_observableCatch((response_: any) => {
      if (response_ instanceof HttpResponseBase) {
        try {
          return this.processGet(<any>response_);
        } catch (e) {
          return <Observable<DeviceDataValueDto>><any>_observableThrow(e);
        }
      } else
        return <Observable<DeviceDataValueDto>><any>_observableThrow(response_);
    }));
  }

  protected processGet(response: HttpResponseBase): Observable<DeviceDataValueDto> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse ? response.body :
        (<any>response).error instanceof Blob ? (<any>response).error : undefined;

    let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
    if (status === 200) {
      return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
        let result200: any = null;
        let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
        result200 = resultData200 ? DeviceDataValueDto.fromJS(resultData200) : new DeviceDataValueDto();
        return _observableOf(result200);
      }));
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
        return throwException("An unexpected server error occurred.", status, _responseText, _headers);
      }));
    }
    return _observableOf<DeviceDataValueDto>(<any>null);
  }

  /**
   * @skipCount (optional)
   * @maxResultCount (optional)
   * @return Success
   */
  getAll(skipCount: number | null | undefined, maxResultCount: number | null | undefined): Observable<PagedResultDtoOfDeviceDataValueDto> {
    let url_ = this.baseUrl + "/api/services/app/DeviceDataValue/GetAll?";
    if (skipCount !== undefined)
      url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
    if (maxResultCount !== undefined)
      url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
    url_ = url_.replace(/[?&]$/, "");

    let options_ : any = {
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({
        "Content-Type": "application/json",
        "Accept": "application/json"
      })
    };

    return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
      return this.processGetAll(response_);
    })).pipe(_observableCatch((response_: any) => {
      if (response_ instanceof HttpResponseBase) {
        try {
          return this.processGetAll(<any>response_);
        } catch (e) {
          return <Observable<PagedResultDtoOfDeviceDataValueDto>><any>_observableThrow(e);
        }
      } else
        return <Observable<PagedResultDtoOfDeviceDataValueDto>><any>_observableThrow(response_);
    }));
  }

  protected processGetAll(response: HttpResponseBase): Observable<PagedResultDtoOfDeviceDataValueDto> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse ? response.body :
        (<any>response).error instanceof Blob ? (<any>response).error : undefined;

    let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
    if (status === 200) {
      return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
        let result200: any = null;
        let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
        result200 = resultData200 ? PagedResultDtoOfDeviceDataValueDto.fromJS(resultData200) : new PagedResultDtoOfDeviceDataValueDto();
        return _observableOf(result200);
      }));
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
        return throwException("An unexpected server error occurred.", status, _responseText, _headers);
      }));
    }
    return _observableOf<PagedResultDtoOfDeviceDataValueDto>(<any>null);
  }

  /**
   * @id (optional)
   * @return Success
   */
  delete(id: string | null | undefined): Observable<void> {
    let url_ = this.baseUrl + "/api/services/app/DeviceDataValue/Delete?";
    if (id !== undefined)
      url_ += "Id=" + encodeURIComponent("" + id) + "&";
    url_ = url_.replace(/[?&]$/, "");

    let options_ : any = {
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({
        "Content-Type": "application/json",
      })
    };

    return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
      return this.processDelete(response_);
    })).pipe(_observableCatch((response_: any) => {
      if (response_ instanceof HttpResponseBase) {
        try {
          return this.processDelete(<any>response_);
        } catch (e) {
          return <Observable<void>><any>_observableThrow(e);
        }
      } else
        return <Observable<void>><any>_observableThrow(response_);
    }));
  }

  protected processDelete(response: HttpResponseBase): Observable<void> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse ? response.body :
        (<any>response).error instanceof Blob ? (<any>response).error : undefined;

    let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
    if (status === 200) {
      return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
        return _observableOf<void>(<any>null);
      }));
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
        return throwException("An unexpected server error occurred.", status, _responseText, _headers);
      }));
    }
    return _observableOf<void>(<any>null);
  }
}

@Injectable()
export class EnterpriseServiceProxy {
  private http: HttpClient;
  private baseUrl: string;
  protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

  constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
    this.http = http;
    this.baseUrl = baseUrl ? baseUrl : "";
  }

  /**
   * @input (optional)
   * @return Success
   */
  create(input: CreateEnterpriseDto | null | undefined): Observable<EnterpriseDto> {
    let url_ = this.baseUrl + "/api/services/app/Enterprise/Create";
    url_ = url_.replace(/[?&]$/, "");

    const content_ = JSON.stringify(input);

    let options_ : any = {
      body: content_,
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({
        "Content-Type": "application/json",
        "Accept": "application/json"
      })
    };

    return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
      return this.processCreate(response_);
    })).pipe(_observableCatch((response_: any) => {
      if (response_ instanceof HttpResponseBase) {
        try {
          return this.processCreate(<any>response_);
        } catch (e) {
          return <Observable<EnterpriseDto>><any>_observableThrow(e);
        }
      } else
        return <Observable<EnterpriseDto>><any>_observableThrow(response_);
    }));
  }

  protected processCreate(response: HttpResponseBase): Observable<EnterpriseDto> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse ? response.body :
        (<any>response).error instanceof Blob ? (<any>response).error : undefined;

    let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
    if (status === 200) {
      return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
        let result200: any = null;
        let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
        result200 = resultData200 ? EnterpriseDto.fromJS(resultData200) : new EnterpriseDto();
        return _observableOf(result200);
      }));
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
        return throwException("An unexpected server error occurred.", status, _responseText, _headers);
      }));
    }
    return _observableOf<EnterpriseDto>(<any>null);
  }

  /**
   * @input (optional)
   * @return Success
   */
  update(input: EnterpriseDto | null | undefined): Observable<EnterpriseDto> {
    let url_ = this.baseUrl + "/api/services/app/Enterprise/Update";
    url_ = url_.replace(/[?&]$/, "");

    const content_ = JSON.stringify(input);

    let options_ : any = {
      body: content_,
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({
        "Content-Type": "application/json",
        "Accept": "application/json"
      })
    };

    return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
      return this.processUpdate(response_);
    })).pipe(_observableCatch((response_: any) => {
      if (response_ instanceof HttpResponseBase) {
        try {
          return this.processUpdate(<any>response_);
        } catch (e) {
          return <Observable<EnterpriseDto>><any>_observableThrow(e);
        }
      } else
        return <Observable<EnterpriseDto>><any>_observableThrow(response_);
    }));
  }

  protected processUpdate(response: HttpResponseBase): Observable<EnterpriseDto> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse ? response.body :
        (<any>response).error instanceof Blob ? (<any>response).error : undefined;

    let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
    if (status === 200) {
      return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
        let result200: any = null;
        let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
        result200 = resultData200 ? EnterpriseDto.fromJS(resultData200) : new EnterpriseDto();
        return _observableOf(result200);
      }));
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
        return throwException("An unexpected server error occurred.", status, _responseText, _headers);
      }));
    }
    return _observableOf<EnterpriseDto>(<any>null);
  }

  /**
   * @id (optional)
   * @return Success
   */
  get(id: number | null | undefined): Observable<EnterpriseDto> {
    let url_ = this.baseUrl + "/api/services/app/Enterprise/Get?";
    if (id !== undefined)
      url_ += "Id=" + encodeURIComponent("" + id) + "&";
    url_ = url_.replace(/[?&]$/, "");

    let options_ : any = {
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({
        "Content-Type": "application/json",
        "Accept": "application/json"
      })
    };

    return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
      return this.processGet(response_);
    })).pipe(_observableCatch((response_: any) => {
      if (response_ instanceof HttpResponseBase) {
        try {
          return this.processGet(<any>response_);
        } catch (e) {
          return <Observable<EnterpriseDto>><any>_observableThrow(e);
        }
      } else
        return <Observable<EnterpriseDto>><any>_observableThrow(response_);
    }));
  }

  protected processGet(response: HttpResponseBase): Observable<EnterpriseDto> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse ? response.body :
        (<any>response).error instanceof Blob ? (<any>response).error : undefined;

    let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
    if (status === 200) {
      return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
        let result200: any = null;
        let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
        result200 = resultData200 ? EnterpriseDto.fromJS(resultData200) : new EnterpriseDto();
        return _observableOf(result200);
      }));
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
        return throwException("An unexpected server error occurred.", status, _responseText, _headers);
      }));
    }
    return _observableOf<EnterpriseDto>(<any>null);
  }

  /**
   * @skipCount (optional)
   * @maxResultCount (optional)
   * @return Success
   */
  getAll(skipCount: number | null | undefined, maxResultCount: number | null | undefined): Observable<PagedResultDtoOfEnterpriseDto> {
    let url_ = this.baseUrl + "/api/services/app/Enterprise/GetAll?";
    if (skipCount !== undefined)
      url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
    if (maxResultCount !== undefined)
      url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
    url_ = url_.replace(/[?&]$/, "");

    let options_ : any = {
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({
        "Content-Type": "application/json",
        "Accept": "application/json"
      })
    };

    return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
      return this.processGetAll(response_);
    })).pipe(_observableCatch((response_: any) => {
      if (response_ instanceof HttpResponseBase) {
        try {
          return this.processGetAll(<any>response_);
        } catch (e) {
          return <Observable<PagedResultDtoOfEnterpriseDto>><any>_observableThrow(e);
        }
      } else
        return <Observable<PagedResultDtoOfEnterpriseDto>><any>_observableThrow(response_);
    }));
  }

  protected processGetAll(response: HttpResponseBase): Observable<PagedResultDtoOfEnterpriseDto> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse ? response.body :
        (<any>response).error instanceof Blob ? (<any>response).error : undefined;

    let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
    if (status === 200) {
      return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
        let result200: any = null;
        let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
        result200 = resultData200 ? PagedResultDtoOfEnterpriseDto.fromJS(resultData200) : new PagedResultDtoOfEnterpriseDto();
        return _observableOf(result200);
      }));
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
        return throwException("An unexpected server error occurred.", status, _responseText, _headers);
      }));
    }
    return _observableOf<PagedResultDtoOfEnterpriseDto>(<any>null);
  }

  /**
   * @id (optional)
   * @return Success
   */
  delete(id: number | null | undefined): Observable<void> {
    let url_ = this.baseUrl + "/api/services/app/Enterprise/Delete?";
    if (id !== undefined)
      url_ += "Id=" + encodeURIComponent("" + id) + "&";
    url_ = url_.replace(/[?&]$/, "");

    let options_ : any = {
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({
        "Content-Type": "application/json",
      })
    };

    return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
      return this.processDelete(response_);
    })).pipe(_observableCatch((response_: any) => {
      if (response_ instanceof HttpResponseBase) {
        try {
          return this.processDelete(<any>response_);
        } catch (e) {
          return <Observable<void>><any>_observableThrow(e);
        }
      } else
        return <Observable<void>><any>_observableThrow(response_);
    }));
  }

  protected processDelete(response: HttpResponseBase): Observable<void> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse ? response.body :
        (<any>response).error instanceof Blob ? (<any>response).error : undefined;

    let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
    if (status === 200) {
      return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
        return _observableOf<void>(<any>null);
      }));
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
        return throwException("An unexpected server error occurred.", status, _responseText, _headers);
      }));
    }
    return _observableOf<void>(<any>null);
  }
}

@Injectable()
export class FactoryServiceProxy {
  private http: HttpClient;
  private baseUrl: string;
  protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

  constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
    this.http = http;
    this.baseUrl = baseUrl ? baseUrl : "";
  }

  /**
   * @input (optional)
   * @return Success
   */
  create(input: CreateFactoryDto | null | undefined): Observable<FactoryDto> {
    let url_ = this.baseUrl + "/api/services/app/Factory/Create";
    url_ = url_.replace(/[?&]$/, "");

    const content_ = JSON.stringify(input);

    let options_ : any = {
      body: content_,
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({
        "Content-Type": "application/json",
        "Accept": "application/json"
      })
    };

    return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
      return this.processCreate(response_);
    })).pipe(_observableCatch((response_: any) => {
      if (response_ instanceof HttpResponseBase) {
        try {
          return this.processCreate(<any>response_);
        } catch (e) {
          return <Observable<FactoryDto>><any>_observableThrow(e);
        }
      } else
        return <Observable<FactoryDto>><any>_observableThrow(response_);
    }));
  }

  protected processCreate(response: HttpResponseBase): Observable<FactoryDto> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse ? response.body :
        (<any>response).error instanceof Blob ? (<any>response).error : undefined;

    let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
    if (status === 200) {
      return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
        let result200: any = null;
        let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
        result200 = resultData200 ? FactoryDto.fromJS(resultData200) : new FactoryDto();
        return _observableOf(result200);
      }));
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
        return throwException("An unexpected server error occurred.", status, _responseText, _headers);
      }));
    }
    return _observableOf<FactoryDto>(<any>null);
  }

  /**
   * @input (optional)
   * @return Success
   */
  update(input: FactoryDto | null | undefined): Observable<FactoryDto> {
    let url_ = this.baseUrl + "/api/services/app/Factory/Update";
    url_ = url_.replace(/[?&]$/, "");

    const content_ = JSON.stringify(input);

    let options_ : any = {
      body: content_,
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({
        "Content-Type": "application/json",
        "Accept": "application/json"
      })
    };

    return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
      return this.processUpdate(response_);
    })).pipe(_observableCatch((response_: any) => {
      if (response_ instanceof HttpResponseBase) {
        try {
          return this.processUpdate(<any>response_);
        } catch (e) {
          return <Observable<FactoryDto>><any>_observableThrow(e);
        }
      } else
        return <Observable<FactoryDto>><any>_observableThrow(response_);
    }));
  }

  protected processUpdate(response: HttpResponseBase): Observable<FactoryDto> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse ? response.body :
        (<any>response).error instanceof Blob ? (<any>response).error : undefined;

    let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
    if (status === 200) {
      return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
        let result200: any = null;
        let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
        result200 = resultData200 ? FactoryDto.fromJS(resultData200) : new FactoryDto();
        return _observableOf(result200);
      }));
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
        return throwException("An unexpected server error occurred.", status, _responseText, _headers);
      }));
    }
    return _observableOf<FactoryDto>(<any>null);
  }

  /**
   * @id (optional)
   * @return Success
   */
  get(id: number | null | undefined): Observable<FactoryDto> {
    let url_ = this.baseUrl + "/api/services/app/Factory/Get?";
    if (id !== undefined)
      url_ += "Id=" + encodeURIComponent("" + id) + "&";
    url_ = url_.replace(/[?&]$/, "");

    let options_ : any = {
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({
        "Content-Type": "application/json",
        "Accept": "application/json"
      })
    };

    return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
      return this.processGet(response_);
    })).pipe(_observableCatch((response_: any) => {
      if (response_ instanceof HttpResponseBase) {
        try {
          return this.processGet(<any>response_);
        } catch (e) {
          return <Observable<FactoryDto>><any>_observableThrow(e);
        }
      } else
        return <Observable<FactoryDto>><any>_observableThrow(response_);
    }));
  }

  protected processGet(response: HttpResponseBase): Observable<FactoryDto> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse ? response.body :
        (<any>response).error instanceof Blob ? (<any>response).error : undefined;

    let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
    if (status === 200) {
      return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
        let result200: any = null;
        let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
        result200 = resultData200 ? FactoryDto.fromJS(resultData200) : new FactoryDto();
        return _observableOf(result200);
      }));
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
        return throwException("An unexpected server error occurred.", status, _responseText, _headers);
      }));
    }
    return _observableOf<FactoryDto>(<any>null);
  }

  /**
   * @skipCount (optional)
   * @maxResultCount (optional)
   * @return Success
   */
  getAll(skipCount: number | null | undefined, maxResultCount: number | null | undefined): Observable<PagedResultDtoOfFactoryDto> {
    let url_ = this.baseUrl + "/api/services/app/Factory/GetAll?";
    if (skipCount !== undefined)
      url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
    if (maxResultCount !== undefined)
      url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
    url_ = url_.replace(/[?&]$/, "");

    let options_ : any = {
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({
        "Content-Type": "application/json",
        "Accept": "application/json"
      })
    };

    return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
      return this.processGetAll(response_);
    })).pipe(_observableCatch((response_: any) => {
      if (response_ instanceof HttpResponseBase) {
        try {
          return this.processGetAll(<any>response_);
        } catch (e) {
          return <Observable<PagedResultDtoOfFactoryDto>><any>_observableThrow(e);
        }
      } else
        return <Observable<PagedResultDtoOfFactoryDto>><any>_observableThrow(response_);
    }));
  }

  protected processGetAll(response: HttpResponseBase): Observable<PagedResultDtoOfFactoryDto> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse ? response.body :
        (<any>response).error instanceof Blob ? (<any>response).error : undefined;

    let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
    if (status === 200) {
      return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
        let result200: any = null;
        let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
        result200 = resultData200 ? PagedResultDtoOfFactoryDto.fromJS(resultData200) : new PagedResultDtoOfFactoryDto();
        return _observableOf(result200);
      }));
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
        return throwException("An unexpected server error occurred.", status, _responseText, _headers);
      }));
    }
    return _observableOf<PagedResultDtoOfFactoryDto>(<any>null);
  }

  /**
   * @id (optional)
   * @return Success
   */
  delete(id: number | null | undefined): Observable<void> {
    let url_ = this.baseUrl + "/api/services/app/Factory/Delete?";
    if (id !== undefined)
      url_ += "Id=" + encodeURIComponent("" + id) + "&";
    url_ = url_.replace(/[?&]$/, "");

    let options_ : any = {
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({
        "Content-Type": "application/json",
      })
    };

    return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
      return this.processDelete(response_);
    })).pipe(_observableCatch((response_: any) => {
      if (response_ instanceof HttpResponseBase) {
        try {
          return this.processDelete(<any>response_);
        } catch (e) {
          return <Observable<void>><any>_observableThrow(e);
        }
      } else
        return <Observable<void>><any>_observableThrow(response_);
    }));
  }

  protected processDelete(response: HttpResponseBase): Observable<void> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse ? response.body :
        (<any>response).error instanceof Blob ? (<any>response).error : undefined;

    let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
    if (status === 200) {
      return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
        return _observableOf<void>(<any>null);
      }));
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
        return throwException("An unexpected server error occurred.", status, _responseText, _headers);
      }));
    }
    return _observableOf<void>(<any>null);
  }
}

@Injectable()
export class GroupServiceProxy {
  private http: HttpClient;
  private baseUrl: string;
  protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

  constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
    this.http = http;
    this.baseUrl = baseUrl ? baseUrl : "";
  }

  /**
   * @input (optional)
   * @return Success
   */
  create(input: CreateGroupDto | null | undefined): Observable<GroupDto> {
    let url_ = this.baseUrl + "/api/services/app/Group/Create";
    url_ = url_.replace(/[?&]$/, "");

    const content_ = JSON.stringify(input);

    let options_ : any = {
      body: content_,
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({
        "Content-Type": "application/json",
        "Accept": "application/json"
      })
    };

    return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
      return this.processCreate(response_);
    })).pipe(_observableCatch((response_: any) => {
      if (response_ instanceof HttpResponseBase) {
        try {
          return this.processCreate(<any>response_);
        } catch (e) {
          return <Observable<GroupDto>><any>_observableThrow(e);
        }
      } else
        return <Observable<GroupDto>><any>_observableThrow(response_);
    }));
  }

  protected processCreate(response: HttpResponseBase): Observable<GroupDto> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse ? response.body :
        (<any>response).error instanceof Blob ? (<any>response).error : undefined;

    let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
    if (status === 200) {
      return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
        let result200: any = null;
        let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
        result200 = resultData200 ? GroupDto.fromJS(resultData200) : new GroupDto();
        return _observableOf(result200);
      }));
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
        return throwException("An unexpected server error occurred.", status, _responseText, _headers);
      }));
    }
    return _observableOf<GroupDto>(<any>null);
  }

  /**
   * @input (optional)
   * @return Success
   */
  update(input: GroupDto | null | undefined): Observable<GroupDto> {
    let url_ = this.baseUrl + "/api/services/app/Group/Update";
    url_ = url_.replace(/[?&]$/, "");

    const content_ = JSON.stringify(input);

    let options_ : any = {
      body: content_,
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({
        "Content-Type": "application/json",
        "Accept": "application/json"
      })
    };

    return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
      return this.processUpdate(response_);
    })).pipe(_observableCatch((response_: any) => {
      if (response_ instanceof HttpResponseBase) {
        try {
          return this.processUpdate(<any>response_);
        } catch (e) {
          return <Observable<GroupDto>><any>_observableThrow(e);
        }
      } else
        return <Observable<GroupDto>><any>_observableThrow(response_);
    }));
  }

  protected processUpdate(response: HttpResponseBase): Observable<GroupDto> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse ? response.body :
        (<any>response).error instanceof Blob ? (<any>response).error : undefined;

    let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
    if (status === 200) {
      return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
        let result200: any = null;
        let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
        result200 = resultData200 ? GroupDto.fromJS(resultData200) : new GroupDto();
        return _observableOf(result200);
      }));
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
        return throwException("An unexpected server error occurred.", status, _responseText, _headers);
      }));
    }
    return _observableOf<GroupDto>(<any>null);
  }

  /**
   * @id (optional)
   * @return Success
   */
  get(id: number | null | undefined): Observable<GroupDto> {
    let url_ = this.baseUrl + "/api/services/app/Group/Get?";
    if (id !== undefined)
      url_ += "Id=" + encodeURIComponent("" + id) + "&";
    url_ = url_.replace(/[?&]$/, "");

    let options_ : any = {
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({
        "Content-Type": "application/json",
        "Accept": "application/json"
      })
    };

    return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
      return this.processGet(response_);
    })).pipe(_observableCatch((response_: any) => {
      if (response_ instanceof HttpResponseBase) {
        try {
          return this.processGet(<any>response_);
        } catch (e) {
          return <Observable<GroupDto>><any>_observableThrow(e);
        }
      } else
        return <Observable<GroupDto>><any>_observableThrow(response_);
    }));
  }

  protected processGet(response: HttpResponseBase): Observable<GroupDto> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse ? response.body :
        (<any>response).error instanceof Blob ? (<any>response).error : undefined;

    let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
    if (status === 200) {
      return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
        let result200: any = null;
        let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
        result200 = resultData200 ? GroupDto.fromJS(resultData200) : new GroupDto();
        return _observableOf(result200);
      }));
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
        return throwException("An unexpected server error occurred.", status, _responseText, _headers);
      }));
    }
    return _observableOf<GroupDto>(<any>null);
  }

  /**
   * @skipCount (optional)
   * @maxResultCount (optional)
   * @return Success
   */
  getAll(skipCount: number | null | undefined, maxResultCount: number | null | undefined): Observable<PagedResultDtoOfGroupDto> {
    let url_ = this.baseUrl + "/api/services/app/Group/GetAll?";
    if (skipCount !== undefined)
      url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
    if (maxResultCount !== undefined)
      url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
    url_ = url_.replace(/[?&]$/, "");

    let options_ : any = {
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({
        "Content-Type": "application/json",
        "Accept": "application/json"
      })
    };

    return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
      return this.processGetAll(response_);
    })).pipe(_observableCatch((response_: any) => {
      if (response_ instanceof HttpResponseBase) {
        try {
          return this.processGetAll(<any>response_);
        } catch (e) {
          return <Observable<PagedResultDtoOfGroupDto>><any>_observableThrow(e);
        }
      } else
        return <Observable<PagedResultDtoOfGroupDto>><any>_observableThrow(response_);
    }));
  }

  protected processGetAll(response: HttpResponseBase): Observable<PagedResultDtoOfGroupDto> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse ? response.body :
        (<any>response).error instanceof Blob ? (<any>response).error : undefined;

    let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
    if (status === 200) {
      return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
        let result200: any = null;
        let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
        result200 = resultData200 ? PagedResultDtoOfGroupDto.fromJS(resultData200) : new PagedResultDtoOfGroupDto();
        return _observableOf(result200);
      }));
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
        return throwException("An unexpected server error occurred.", status, _responseText, _headers);
      }));
    }
    return _observableOf<PagedResultDtoOfGroupDto>(<any>null);
  }

  /**
   * @id (optional)
   * @return Success
   */
  delete(id: number | null | undefined): Observable<void> {
    let url_ = this.baseUrl + "/api/services/app/Group/Delete?";
    if (id !== undefined)
      url_ += "Id=" + encodeURIComponent("" + id) + "&";
    url_ = url_.replace(/[?&]$/, "");

    let options_ : any = {
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({
        "Content-Type": "application/json",
      })
    };

    return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
      return this.processDelete(response_);
    })).pipe(_observableCatch((response_: any) => {
      if (response_ instanceof HttpResponseBase) {
        try {
          return this.processDelete(<any>response_);
        } catch (e) {
          return <Observable<void>><any>_observableThrow(e);
        }
      } else
        return <Observable<void>><any>_observableThrow(response_);
    }));
  }

  protected processDelete(response: HttpResponseBase): Observable<void> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse ? response.body :
        (<any>response).error instanceof Blob ? (<any>response).error : undefined;

    let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
    if (status === 200) {
      return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
        return _observableOf<void>(<any>null);
      }));
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
        return throwException("An unexpected server error occurred.", status, _responseText, _headers);
      }));
    }
    return _observableOf<void>(<any>null);
  }
}

@Injectable()
export class ProductionLineServiceProxy {
  private http: HttpClient;
  private baseUrl: string;
  protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

  constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
    this.http = http;
    this.baseUrl = baseUrl ? baseUrl : "";
  }

  /**
   * @input (optional)
   * @return Success
   */
  create(input: CreateProductionLineDto | null | undefined): Observable<ProductionLineDto> {
    let url_ = this.baseUrl + "/api/services/app/ProductionLine/Create";
    url_ = url_.replace(/[?&]$/, "");

    const content_ = JSON.stringify(input);

    let options_ : any = {
      body: content_,
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({
        "Content-Type": "application/json",
        "Accept": "application/json"
      })
    };

    return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
      return this.processCreate(response_);
    })).pipe(_observableCatch((response_: any) => {
      if (response_ instanceof HttpResponseBase) {
        try {
          return this.processCreate(<any>response_);
        } catch (e) {
          return <Observable<ProductionLineDto>><any>_observableThrow(e);
        }
      } else
        return <Observable<ProductionLineDto>><any>_observableThrow(response_);
    }));
  }

  protected processCreate(response: HttpResponseBase): Observable<ProductionLineDto> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse ? response.body :
        (<any>response).error instanceof Blob ? (<any>response).error : undefined;

    let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
    if (status === 200) {
      return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
        let result200: any = null;
        let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
        result200 = resultData200 ? ProductionLineDto.fromJS(resultData200) : new ProductionLineDto();
        return _observableOf(result200);
      }));
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
        return throwException("An unexpected server error occurred.", status, _responseText, _headers);
      }));
    }
    return _observableOf<ProductionLineDto>(<any>null);
  }

  /**
   * @input (optional)
   * @return Success
   */
  update(input: ProductionLineDto | null | undefined): Observable<ProductionLineDto> {
    let url_ = this.baseUrl + "/api/services/app/ProductionLine/Update";
    url_ = url_.replace(/[?&]$/, "");

    const content_ = JSON.stringify(input);

    let options_ : any = {
      body: content_,
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({
        "Content-Type": "application/json",
        "Accept": "application/json"
      })
    };

    return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
      return this.processUpdate(response_);
    })).pipe(_observableCatch((response_: any) => {
      if (response_ instanceof HttpResponseBase) {
        try {
          return this.processUpdate(<any>response_);
        } catch (e) {
          return <Observable<ProductionLineDto>><any>_observableThrow(e);
        }
      } else
        return <Observable<ProductionLineDto>><any>_observableThrow(response_);
    }));
  }

  protected processUpdate(response: HttpResponseBase): Observable<ProductionLineDto> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse ? response.body :
        (<any>response).error instanceof Blob ? (<any>response).error : undefined;

    let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
    if (status === 200) {
      return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
        let result200: any = null;
        let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
        result200 = resultData200 ? ProductionLineDto.fromJS(resultData200) : new ProductionLineDto();
        return _observableOf(result200);
      }));
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
        return throwException("An unexpected server error occurred.", status, _responseText, _headers);
      }));
    }
    return _observableOf<ProductionLineDto>(<any>null);
  }

  /**
   * @return Success
   */
  getProductionLineParams(): Observable<ProductionLineParamDto[]> {
    let url_ = this.baseUrl + "/api/services/app/ProductionLine/GetProductionLineParams";
    url_ = url_.replace(/[?&]$/, "");

    let options_ : any = {
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({
        "Content-Type": "application/json",
        "Accept": "application/json"
      })
    };

    return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
      return this.processGetProductionLineParams(response_);
    })).pipe(_observableCatch((response_: any) => {
      if (response_ instanceof HttpResponseBase) {
        try {
          return this.processGetProductionLineParams(<any>response_);
        } catch (e) {
          return <Observable<ProductionLineParamDto[]>><any>_observableThrow(e);
        }
      } else
        return <Observable<ProductionLineParamDto[]>><any>_observableThrow(response_);
    }));
  }

  protected processGetProductionLineParams(response: HttpResponseBase): Observable<ProductionLineParamDto[]> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse ? response.body :
        (<any>response).error instanceof Blob ? (<any>response).error : undefined;

    let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
    if (status === 200) {
      return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
        let result200: any = null;
        let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
        if (resultData200 && resultData200.constructor === Array) {
          result200 = [];
          for (let item of resultData200)
            result200.push(ProductionLineParamDto.fromJS(item));
        }
        return _observableOf(result200);
      }));
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
        return throwException("An unexpected server error occurred.", status, _responseText, _headers);
      }));
    }
    return _observableOf<ProductionLineParamDto[]>(<any>null);
  }

  /**
   * @id (optional)
   * @return Success
   */
  get(id: number | null | undefined): Observable<ProductionLineDto> {
    let url_ = this.baseUrl + "/api/services/app/ProductionLine/Get?";
    if (id !== undefined)
      url_ += "Id=" + encodeURIComponent("" + id) + "&";
    url_ = url_.replace(/[?&]$/, "");

    let options_ : any = {
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({
        "Content-Type": "application/json",
        "Accept": "application/json"
      })
    };

    return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
      return this.processGet(response_);
    })).pipe(_observableCatch((response_: any) => {
      if (response_ instanceof HttpResponseBase) {
        try {
          return this.processGet(<any>response_);
        } catch (e) {
          return <Observable<ProductionLineDto>><any>_observableThrow(e);
        }
      } else
        return <Observable<ProductionLineDto>><any>_observableThrow(response_);
    }));
  }

  protected processGet(response: HttpResponseBase): Observable<ProductionLineDto> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse ? response.body :
        (<any>response).error instanceof Blob ? (<any>response).error : undefined;

    let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
    if (status === 200) {
      return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
        let result200: any = null;
        let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
        result200 = resultData200 ? ProductionLineDto.fromJS(resultData200) : new ProductionLineDto();
        return _observableOf(result200);
      }));
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
        return throwException("An unexpected server error occurred.", status, _responseText, _headers);
      }));
    }
    return _observableOf<ProductionLineDto>(<any>null);
  }

  /**
   * @skipCount (optional)
   * @maxResultCount (optional)
   * @return Success
   */
  getAll(skipCount: number | null | undefined, maxResultCount: number | null | undefined): Observable<PagedResultDtoOfProductionLineDto> {
    let url_ = this.baseUrl + "/api/services/app/ProductionLine/GetAll?";
    if (skipCount !== undefined)
      url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
    if (maxResultCount !== undefined)
      url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
    url_ = url_.replace(/[?&]$/, "");

    let options_ : any = {
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({
        "Content-Type": "application/json",
        "Accept": "application/json"
      })
    };

    return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
      return this.processGetAll(response_);
    })).pipe(_observableCatch((response_: any) => {
      if (response_ instanceof HttpResponseBase) {
        try {
          return this.processGetAll(<any>response_);
        } catch (e) {
          return <Observable<PagedResultDtoOfProductionLineDto>><any>_observableThrow(e);
        }
      } else
        return <Observable<PagedResultDtoOfProductionLineDto>><any>_observableThrow(response_);
    }));
  }

  protected processGetAll(response: HttpResponseBase): Observable<PagedResultDtoOfProductionLineDto> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse ? response.body :
        (<any>response).error instanceof Blob ? (<any>response).error : undefined;

    let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
    if (status === 200) {
      return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
        let result200: any = null;
        let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
        result200 = resultData200 ? PagedResultDtoOfProductionLineDto.fromJS(resultData200) : new PagedResultDtoOfProductionLineDto();
        return _observableOf(result200);
      }));
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
        return throwException("An unexpected server error occurred.", status, _responseText, _headers);
      }));
    }
    return _observableOf<PagedResultDtoOfProductionLineDto>(<any>null);
  }

  /**
   * @id (optional)
   * @return Success
   */
  delete(id: number | null | undefined): Observable<void> {
    let url_ = this.baseUrl + "/api/services/app/ProductionLine/Delete?";
    if (id !== undefined)
      url_ += "Id=" + encodeURIComponent("" + id) + "&";
    url_ = url_.replace(/[?&]$/, "");

    let options_ : any = {
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({
        "Content-Type": "application/json",
      })
    };

    return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
      return this.processDelete(response_);
    })).pipe(_observableCatch((response_: any) => {
      if (response_ instanceof HttpResponseBase) {
        try {
          return this.processDelete(<any>response_);
        } catch (e) {
          return <Observable<void>><any>_observableThrow(e);
        }
      } else
        return <Observable<void>><any>_observableThrow(response_);
    }));
  }

  protected processDelete(response: HttpResponseBase): Observable<void> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse ? response.body :
        (<any>response).error instanceof Blob ? (<any>response).error : undefined;

    let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
    if (status === 200) {
      return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
        return _observableOf<void>(<any>null);
      }));
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
        return throwException("An unexpected server error occurred.", status, _responseText, _headers);
      }));
    }
    return _observableOf<void>(<any>null);
  }
}

@Injectable()
export class RoleServiceProxy {
  private http: HttpClient;
  private baseUrl: string;
  protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

  constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
    this.http = http;
    this.baseUrl = baseUrl ? baseUrl : "";
  }

  /**
   * @input (optional)
   * @return Success
   */
  create(input: CreateRoleDto | null | undefined): Observable<RoleDto> {
    let url_ = this.baseUrl + "/api/services/app/Role/Create";
    url_ = url_.replace(/[?&]$/, "");

    const content_ = JSON.stringify(input);

    let options_ : any = {
      body: content_,
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({
        "Content-Type": "application/json",
        "Accept": "application/json"
      })
    };

    return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
      return this.processCreate(response_);
    })).pipe(_observableCatch((response_: any) => {
      if (response_ instanceof HttpResponseBase) {
        try {
          return this.processCreate(<any>response_);
        } catch (e) {
          return <Observable<RoleDto>><any>_observableThrow(e);
        }
      } else
        return <Observable<RoleDto>><any>_observableThrow(response_);
    }));
  }

  protected processCreate(response: HttpResponseBase): Observable<RoleDto> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse ? response.body :
        (<any>response).error instanceof Blob ? (<any>response).error : undefined;

    let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
    if (status === 200) {
      return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
        let result200: any = null;
        let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
        result200 = resultData200 ? RoleDto.fromJS(resultData200) : new RoleDto();
        return _observableOf(result200);
      }));
    } else if (status === 401) {
      return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
        return throwException("A server error occurred.", status, _responseText, _headers);
      }));
    } else if (status === 403) {
      return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
        return throwException("A server error occurred.", status, _responseText, _headers);
      }));
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
        return throwException("An unexpected server error occurred.", status, _responseText, _headers);
      }));
    }
    return _observableOf<RoleDto>(<any>null);
  }

  /**
   * @input (optional)
   * @return Success
   */
  update(input: RoleDto | null | undefined): Observable<RoleDto> {
    let url_ = this.baseUrl + "/api/services/app/Role/Update";
    url_ = url_.replace(/[?&]$/, "");

    const content_ = JSON.stringify(input);

    let options_ : any = {
      body: content_,
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({
        "Content-Type": "application/json",
        "Accept": "application/json"
      })
    };

    return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
      return this.processUpdate(response_);
    })).pipe(_observableCatch((response_: any) => {
      if (response_ instanceof HttpResponseBase) {
        try {
          return this.processUpdate(<any>response_);
        } catch (e) {
          return <Observable<RoleDto>><any>_observableThrow(e);
        }
      } else
        return <Observable<RoleDto>><any>_observableThrow(response_);
    }));
  }

  protected processUpdate(response: HttpResponseBase): Observable<RoleDto> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse ? response.body :
        (<any>response).error instanceof Blob ? (<any>response).error : undefined;

    let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
    if (status === 200) {
      return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
        let result200: any = null;
        let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
        result200 = resultData200 ? RoleDto.fromJS(resultData200) : new RoleDto();
        return _observableOf(result200);
      }));
    } else if (status === 401) {
      return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
        return throwException("A server error occurred.", status, _responseText, _headers);
      }));
    } else if (status === 403) {
      return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
        return throwException("A server error occurred.", status, _responseText, _headers);
      }));
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
        return throwException("An unexpected server error occurred.", status, _responseText, _headers);
      }));
    }
    return _observableOf<RoleDto>(<any>null);
  }

  /**
   * @id (optional)
   * @return Success
   */
  delete(id: number | null | undefined): Observable<void> {
    let url_ = this.baseUrl + "/api/services/app/Role/Delete?";
    if (id !== undefined)
      url_ += "Id=" + encodeURIComponent("" + id) + "&";
    url_ = url_.replace(/[?&]$/, "");

    let options_ : any = {
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({
        "Content-Type": "application/json",
      })
    };

    return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
      return this.processDelete(response_);
    })).pipe(_observableCatch((response_: any) => {
      if (response_ instanceof HttpResponseBase) {
        try {
          return this.processDelete(<any>response_);
        } catch (e) {
          return <Observable<void>><any>_observableThrow(e);
        }
      } else
        return <Observable<void>><any>_observableThrow(response_);
    }));
  }

  protected processDelete(response: HttpResponseBase): Observable<void> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse ? response.body :
        (<any>response).error instanceof Blob ? (<any>response).error : undefined;

    let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
    if (status === 200) {
      return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
        return _observableOf<void>(<any>null);
      }));
    } else if (status === 401) {
      return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
        return throwException("A server error occurred.", status, _responseText, _headers);
      }));
    } else if (status === 403) {
      return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
        return throwException("A server error occurred.", status, _responseText, _headers);
      }));
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
        return throwException("An unexpected server error occurred.", status, _responseText, _headers);
      }));
    }
    return _observableOf<void>(<any>null);
  }

  /**
   * @return Success
   */
  getAllPermissions(): Observable<ListResultDtoOfPermissionDto> {
    let url_ = this.baseUrl + "/api/services/app/Role/GetAllPermissions";
    url_ = url_.replace(/[?&]$/, "");

    let options_ : any = {
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({
        "Content-Type": "application/json",
        "Accept": "application/json"
      })
    };

    return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
      return this.processGetAllPermissions(response_);
    })).pipe(_observableCatch((response_: any) => {
      if (response_ instanceof HttpResponseBase) {
        try {
          return this.processGetAllPermissions(<any>response_);
        } catch (e) {
          return <Observable<ListResultDtoOfPermissionDto>><any>_observableThrow(e);
        }
      } else
        return <Observable<ListResultDtoOfPermissionDto>><any>_observableThrow(response_);
    }));
  }

  protected processGetAllPermissions(response: HttpResponseBase): Observable<ListResultDtoOfPermissionDto> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse ? response.body :
        (<any>response).error instanceof Blob ? (<any>response).error : undefined;

    let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
    if (status === 200) {
      return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
        let result200: any = null;
        let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
        result200 = resultData200 ? ListResultDtoOfPermissionDto.fromJS(resultData200) : new ListResultDtoOfPermissionDto();
        return _observableOf(result200);
      }));
    } else if (status === 401) {
      return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
        return throwException("A server error occurred.", status, _responseText, _headers);
      }));
    } else if (status === 403) {
      return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
        return throwException("A server error occurred.", status, _responseText, _headers);
      }));
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
        return throwException("An unexpected server error occurred.", status, _responseText, _headers);
      }));
    }
    return _observableOf<ListResultDtoOfPermissionDto>(<any>null);
  }

  /**
   * @id (optional)
   * @return Success
   */
  getRoleForEdit(id: number | null | undefined): Observable<GetRoleForEditOutput> {
    let url_ = this.baseUrl + "/api/services/app/Role/GetRoleForEdit?";
    if (id !== undefined)
      url_ += "Id=" + encodeURIComponent("" + id) + "&";
    url_ = url_.replace(/[?&]$/, "");

    let options_ : any = {
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({
        "Content-Type": "application/json",
        "Accept": "application/json"
      })
    };

    return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
      return this.processGetRoleForEdit(response_);
    })).pipe(_observableCatch((response_: any) => {
      if (response_ instanceof HttpResponseBase) {
        try {
          return this.processGetRoleForEdit(<any>response_);
        } catch (e) {
          return <Observable<GetRoleForEditOutput>><any>_observableThrow(e);
        }
      } else
        return <Observable<GetRoleForEditOutput>><any>_observableThrow(response_);
    }));
  }

  protected processGetRoleForEdit(response: HttpResponseBase): Observable<GetRoleForEditOutput> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse ? response.body :
        (<any>response).error instanceof Blob ? (<any>response).error : undefined;

    let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
    if (status === 200) {
      return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
        let result200: any = null;
        let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
        result200 = resultData200 ? GetRoleForEditOutput.fromJS(resultData200) : new GetRoleForEditOutput();
        return _observableOf(result200);
      }));
    } else if (status === 401) {
      return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
        return throwException("A server error occurred.", status, _responseText, _headers);
      }));
    } else if (status === 403) {
      return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
        return throwException("A server error occurred.", status, _responseText, _headers);
      }));
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
        return throwException("An unexpected server error occurred.", status, _responseText, _headers);
      }));
    }
    return _observableOf<GetRoleForEditOutput>(<any>null);
  }

  /**
   * @id (optional)
   * @return Success
   */
  get(id: number | null | undefined): Observable<RoleDto> {
    let url_ = this.baseUrl + "/api/services/app/Role/Get?";
    if (id !== undefined)
      url_ += "Id=" + encodeURIComponent("" + id) + "&";
    url_ = url_.replace(/[?&]$/, "");

    let options_ : any = {
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({
        "Content-Type": "application/json",
        "Accept": "application/json"
      })
    };

    return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
      return this.processGet(response_);
    })).pipe(_observableCatch((response_: any) => {
      if (response_ instanceof HttpResponseBase) {
        try {
          return this.processGet(<any>response_);
        } catch (e) {
          return <Observable<RoleDto>><any>_observableThrow(e);
        }
      } else
        return <Observable<RoleDto>><any>_observableThrow(response_);
    }));
  }

  protected processGet(response: HttpResponseBase): Observable<RoleDto> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse ? response.body :
        (<any>response).error instanceof Blob ? (<any>response).error : undefined;

    let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
    if (status === 200) {
      return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
        let result200: any = null;
        let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
        result200 = resultData200 ? RoleDto.fromJS(resultData200) : new RoleDto();
        return _observableOf(result200);
      }));
    } else if (status === 401) {
      return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
        return throwException("A server error occurred.", status, _responseText, _headers);
      }));
    } else if (status === 403) {
      return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
        return throwException("A server error occurred.", status, _responseText, _headers);
      }));
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
        return throwException("An unexpected server error occurred.", status, _responseText, _headers);
      }));
    }
    return _observableOf<RoleDto>(<any>null);
  }

  /**
   * @skipCount (optional)
   * @maxResultCount (optional)
   * @return Success
   */
  getAll(skipCount: number | null | undefined, maxResultCount: number | null | undefined): Observable<PagedResultDtoOfRoleDto> {
    let url_ = this.baseUrl + "/api/services/app/Role/GetAll?";
    if (skipCount !== undefined)
      url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
    if (maxResultCount !== undefined)
      url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
    url_ = url_.replace(/[?&]$/, "");

    let options_ : any = {
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({
        "Content-Type": "application/json",
        "Accept": "application/json"
      })
    };

    return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
      return this.processGetAll(response_);
    })).pipe(_observableCatch((response_: any) => {
      if (response_ instanceof HttpResponseBase) {
        try {
          return this.processGetAll(<any>response_);
        } catch (e) {
          return <Observable<PagedResultDtoOfRoleDto>><any>_observableThrow(e);
        }
      } else
        return <Observable<PagedResultDtoOfRoleDto>><any>_observableThrow(response_);
    }));
  }

  protected processGetAll(response: HttpResponseBase): Observable<PagedResultDtoOfRoleDto> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse ? response.body :
        (<any>response).error instanceof Blob ? (<any>response).error : undefined;

    let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
    if (status === 200) {
      return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
        let result200: any = null;
        let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
        result200 = resultData200 ? PagedResultDtoOfRoleDto.fromJS(resultData200) : new PagedResultDtoOfRoleDto();
        return _observableOf(result200);
      }));
    } else if (status === 401) {
      return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
        return throwException("A server error occurred.", status, _responseText, _headers);
      }));
    } else if (status === 403) {
      return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
        return throwException("A server error occurred.", status, _responseText, _headers);
      }));
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
        return throwException("An unexpected server error occurred.", status, _responseText, _headers);
      }));
    }
    return _observableOf<PagedResultDtoOfRoleDto>(<any>null);
  }
}

@Injectable()
export class SessionServiceProxy {
  private http: HttpClient;
  private baseUrl: string;
  protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

  constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
    this.http = http;
    this.baseUrl = baseUrl ? baseUrl : "";
  }

  /**
   * @return Success
   */
  getCurrentLoginInformations(): Observable<GetCurrentLoginInformationsOutput> {
    let url_ = this.baseUrl + "/api/services/app/Session/GetCurrentLoginInformations";
    url_ = url_.replace(/[?&]$/, "");

    let options_ : any = {
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({
        "Content-Type": "application/json",
        "Accept": "application/json"
      })
    };

    return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
      return this.processGetCurrentLoginInformations(response_);
    })).pipe(_observableCatch((response_: any) => {
      if (response_ instanceof HttpResponseBase) {
        try {
          return this.processGetCurrentLoginInformations(<any>response_);
        } catch (e) {
          return <Observable<GetCurrentLoginInformationsOutput>><any>_observableThrow(e);
        }
      } else
        return <Observable<GetCurrentLoginInformationsOutput>><any>_observableThrow(response_);
    }));
  }

  protected processGetCurrentLoginInformations(response: HttpResponseBase): Observable<GetCurrentLoginInformationsOutput> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse ? response.body :
        (<any>response).error instanceof Blob ? (<any>response).error : undefined;

    let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
    if (status === 200) {
      return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
        let result200: any = null;
        let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
        result200 = resultData200 ? GetCurrentLoginInformationsOutput.fromJS(resultData200) : new GetCurrentLoginInformationsOutput();
        return _observableOf(result200);
      }));
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
        return throwException("An unexpected server error occurred.", status, _responseText, _headers);
      }));
    }
    return _observableOf<GetCurrentLoginInformationsOutput>(<any>null);
  }
}

@Injectable()
export class TenantServiceProxy {
  private http: HttpClient;
  private baseUrl: string;
  protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

  constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
    this.http = http;
    this.baseUrl = baseUrl ? baseUrl : "";
  }

  /**
   * @input (optional)
   * @return Success
   */
  create(input: CreateTenantDto | null | undefined): Observable<TenantDto> {
    let url_ = this.baseUrl + "/api/services/app/Tenant/Create";
    url_ = url_.replace(/[?&]$/, "");

    const content_ = JSON.stringify(input);

    let options_ : any = {
      body: content_,
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({
        "Content-Type": "application/json",
        "Accept": "application/json"
      })
    };

    return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
      return this.processCreate(response_);
    })).pipe(_observableCatch((response_: any) => {
      if (response_ instanceof HttpResponseBase) {
        try {
          return this.processCreate(<any>response_);
        } catch (e) {
          return <Observable<TenantDto>><any>_observableThrow(e);
        }
      } else
        return <Observable<TenantDto>><any>_observableThrow(response_);
    }));
  }

  protected processCreate(response: HttpResponseBase): Observable<TenantDto> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse ? response.body :
        (<any>response).error instanceof Blob ? (<any>response).error : undefined;

    let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
    if (status === 200) {
      return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
        let result200: any = null;
        let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
        result200 = resultData200 ? TenantDto.fromJS(resultData200) : new TenantDto();
        return _observableOf(result200);
      }));
    } else if (status === 401) {
      return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
        return throwException("A server error occurred.", status, _responseText, _headers);
      }));
    } else if (status === 403) {
      return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
        return throwException("A server error occurred.", status, _responseText, _headers);
      }));
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
        return throwException("An unexpected server error occurred.", status, _responseText, _headers);
      }));
    }
    return _observableOf<TenantDto>(<any>null);
  }

  /**
   * @id (optional)
   * @return Success
   */
  delete(id: number | null | undefined): Observable<void> {
    let url_ = this.baseUrl + "/api/services/app/Tenant/Delete?";
    if (id !== undefined)
      url_ += "Id=" + encodeURIComponent("" + id) + "&";
    url_ = url_.replace(/[?&]$/, "");

    let options_ : any = {
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({
        "Content-Type": "application/json",
      })
    };

    return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
      return this.processDelete(response_);
    })).pipe(_observableCatch((response_: any) => {
      if (response_ instanceof HttpResponseBase) {
        try {
          return this.processDelete(<any>response_);
        } catch (e) {
          return <Observable<void>><any>_observableThrow(e);
        }
      } else
        return <Observable<void>><any>_observableThrow(response_);
    }));
  }

  protected processDelete(response: HttpResponseBase): Observable<void> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse ? response.body :
        (<any>response).error instanceof Blob ? (<any>response).error : undefined;

    let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
    if (status === 200) {
      return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
        return _observableOf<void>(<any>null);
      }));
    } else if (status === 401) {
      return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
        return throwException("A server error occurred.", status, _responseText, _headers);
      }));
    } else if (status === 403) {
      return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
        return throwException("A server error occurred.", status, _responseText, _headers);
      }));
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
        return throwException("An unexpected server error occurred.", status, _responseText, _headers);
      }));
    }
    return _observableOf<void>(<any>null);
  }

  /**
   * @id (optional)
   * @return Success
   */
  get(id: number | null | undefined): Observable<TenantDto> {
    let url_ = this.baseUrl + "/api/services/app/Tenant/Get?";
    if (id !== undefined)
      url_ += "Id=" + encodeURIComponent("" + id) + "&";
    url_ = url_.replace(/[?&]$/, "");

    let options_ : any = {
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({
        "Content-Type": "application/json",
        "Accept": "application/json"
      })
    };

    return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
      return this.processGet(response_);
    })).pipe(_observableCatch((response_: any) => {
      if (response_ instanceof HttpResponseBase) {
        try {
          return this.processGet(<any>response_);
        } catch (e) {
          return <Observable<TenantDto>><any>_observableThrow(e);
        }
      } else
        return <Observable<TenantDto>><any>_observableThrow(response_);
    }));
  }

  protected processGet(response: HttpResponseBase): Observable<TenantDto> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse ? response.body :
        (<any>response).error instanceof Blob ? (<any>response).error : undefined;

    let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
    if (status === 200) {
      return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
        let result200: any = null;
        let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
        result200 = resultData200 ? TenantDto.fromJS(resultData200) : new TenantDto();
        return _observableOf(result200);
      }));
    } else if (status === 401) {
      return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
        return throwException("A server error occurred.", status, _responseText, _headers);
      }));
    } else if (status === 403) {
      return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
        return throwException("A server error occurred.", status, _responseText, _headers);
      }));
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
        return throwException("An unexpected server error occurred.", status, _responseText, _headers);
      }));
    }
    return _observableOf<TenantDto>(<any>null);
  }

  /**
   * @skipCount (optional)
   * @maxResultCount (optional)
   * @return Success
   */
  getAll(skipCount: number | null | undefined, maxResultCount: number | null | undefined): Observable<PagedResultDtoOfTenantDto> {
    let url_ = this.baseUrl + "/api/services/app/Tenant/GetAll?";
    if (skipCount !== undefined)
      url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
    if (maxResultCount !== undefined)
      url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
    url_ = url_.replace(/[?&]$/, "");

    let options_ : any = {
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({
        "Content-Type": "application/json",
        "Accept": "application/json"
      })
    };

    return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
      return this.processGetAll(response_);
    })).pipe(_observableCatch((response_: any) => {
      if (response_ instanceof HttpResponseBase) {
        try {
          return this.processGetAll(<any>response_);
        } catch (e) {
          return <Observable<PagedResultDtoOfTenantDto>><any>_observableThrow(e);
        }
      } else
        return <Observable<PagedResultDtoOfTenantDto>><any>_observableThrow(response_);
    }));
  }

  protected processGetAll(response: HttpResponseBase): Observable<PagedResultDtoOfTenantDto> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse ? response.body :
        (<any>response).error instanceof Blob ? (<any>response).error : undefined;

    let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
    if (status === 200) {
      return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
        let result200: any = null;
        let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
        result200 = resultData200 ? PagedResultDtoOfTenantDto.fromJS(resultData200) : new PagedResultDtoOfTenantDto();
        return _observableOf(result200);
      }));
    } else if (status === 401) {
      return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
        return throwException("A server error occurred.", status, _responseText, _headers);
      }));
    } else if (status === 403) {
      return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
        return throwException("A server error occurred.", status, _responseText, _headers);
      }));
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
        return throwException("An unexpected server error occurred.", status, _responseText, _headers);
      }));
    }
    return _observableOf<PagedResultDtoOfTenantDto>(<any>null);
  }

  /**
   * @input (optional)
   * @return Success
   */
  update(input: TenantDto | null | undefined): Observable<TenantDto> {
    let url_ = this.baseUrl + "/api/services/app/Tenant/Update";
    url_ = url_.replace(/[?&]$/, "");

    const content_ = JSON.stringify(input);

    let options_ : any = {
      body: content_,
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({
        "Content-Type": "application/json",
        "Accept": "application/json"
      })
    };

    return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
      return this.processUpdate(response_);
    })).pipe(_observableCatch((response_: any) => {
      if (response_ instanceof HttpResponseBase) {
        try {
          return this.processUpdate(<any>response_);
        } catch (e) {
          return <Observable<TenantDto>><any>_observableThrow(e);
        }
      } else
        return <Observable<TenantDto>><any>_observableThrow(response_);
    }));
  }

  protected processUpdate(response: HttpResponseBase): Observable<TenantDto> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse ? response.body :
        (<any>response).error instanceof Blob ? (<any>response).error : undefined;

    let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
    if (status === 200) {
      return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
        let result200: any = null;
        let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
        result200 = resultData200 ? TenantDto.fromJS(resultData200) : new TenantDto();
        return _observableOf(result200);
      }));
    } else if (status === 401) {
      return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
        return throwException("A server error occurred.", status, _responseText, _headers);
      }));
    } else if (status === 403) {
      return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
        return throwException("A server error occurred.", status, _responseText, _headers);
      }));
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
        return throwException("An unexpected server error occurred.", status, _responseText, _headers);
      }));
    }
    return _observableOf<TenantDto>(<any>null);
  }
}

@Injectable()
export class TokenAuthServiceProxy {
  private http: HttpClient;
  private baseUrl: string;
  protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

  constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
    this.http = http;
    this.baseUrl = baseUrl ? baseUrl : "";
  }

  /**
   * @model (optional)
   * @return Success
   */
  authenticate(model: AuthenticateModel | null | undefined): Observable<AuthenticateResultModel> {
    let url_ = this.baseUrl + "/api/TokenAuth/Authenticate";
    url_ = url_.replace(/[?&]$/, "");

    const content_ = JSON.stringify(model);

    let options_ : any = {
      body: content_,
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({
        "Content-Type": "application/json",
        "Accept": "application/json"
      })
    };

    return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
      return this.processAuthenticate(response_);
    })).pipe(_observableCatch((response_: any) => {
      if (response_ instanceof HttpResponseBase) {
        try {
          return this.processAuthenticate(<any>response_);
        } catch (e) {
          return <Observable<AuthenticateResultModel>><any>_observableThrow(e);
        }
      } else
        return <Observable<AuthenticateResultModel>><any>_observableThrow(response_);
    }));
  }

  protected processAuthenticate(response: HttpResponseBase): Observable<AuthenticateResultModel> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse ? response.body :
        (<any>response).error instanceof Blob ? (<any>response).error : undefined;

    let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
    if (status === 200) {
      return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
        let result200: any = null;
        let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
        result200 = resultData200 ? AuthenticateResultModel.fromJS(resultData200) : new AuthenticateResultModel();
        return _observableOf(result200);
      }));
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
        return throwException("An unexpected server error occurred.", status, _responseText, _headers);
      }));
    }
    return _observableOf<AuthenticateResultModel>(<any>null);
  }

  /**
   * @return Success
   */
  getExternalAuthenticationProviders(): Observable<ExternalLoginProviderInfoModel[]> {
    let url_ = this.baseUrl + "/api/TokenAuth/GetExternalAuthenticationProviders";
    url_ = url_.replace(/[?&]$/, "");

    let options_ : any = {
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({
        "Content-Type": "application/json",
        "Accept": "application/json"
      })
    };

    return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
      return this.processGetExternalAuthenticationProviders(response_);
    })).pipe(_observableCatch((response_: any) => {
      if (response_ instanceof HttpResponseBase) {
        try {
          return this.processGetExternalAuthenticationProviders(<any>response_);
        } catch (e) {
          return <Observable<ExternalLoginProviderInfoModel[]>><any>_observableThrow(e);
        }
      } else
        return <Observable<ExternalLoginProviderInfoModel[]>><any>_observableThrow(response_);
    }));
  }

  protected processGetExternalAuthenticationProviders(response: HttpResponseBase): Observable<ExternalLoginProviderInfoModel[]> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse ? response.body :
        (<any>response).error instanceof Blob ? (<any>response).error : undefined;

    let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
    if (status === 200) {
      return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
        let result200: any = null;
        let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
        if (resultData200 && resultData200.constructor === Array) {
          result200 = [];
          for (let item of resultData200)
            result200.push(ExternalLoginProviderInfoModel.fromJS(item));
        }
        return _observableOf(result200);
      }));
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
        return throwException("An unexpected server error occurred.", status, _responseText, _headers);
      }));
    }
    return _observableOf<ExternalLoginProviderInfoModel[]>(<any>null);
  }

  /**
   * @model (optional)
   * @return Success
   */
  externalAuthenticate(model: ExternalAuthenticateModel | null | undefined): Observable<ExternalAuthenticateResultModel> {
    let url_ = this.baseUrl + "/api/TokenAuth/ExternalAuthenticate";
    url_ = url_.replace(/[?&]$/, "");

    const content_ = JSON.stringify(model);

    let options_ : any = {
      body: content_,
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({
        "Content-Type": "application/json",
        "Accept": "application/json"
      })
    };

    return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
      return this.processExternalAuthenticate(response_);
    })).pipe(_observableCatch((response_: any) => {
      if (response_ instanceof HttpResponseBase) {
        try {
          return this.processExternalAuthenticate(<any>response_);
        } catch (e) {
          return <Observable<ExternalAuthenticateResultModel>><any>_observableThrow(e);
        }
      } else
        return <Observable<ExternalAuthenticateResultModel>><any>_observableThrow(response_);
    }));
  }

  protected processExternalAuthenticate(response: HttpResponseBase): Observable<ExternalAuthenticateResultModel> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse ? response.body :
        (<any>response).error instanceof Blob ? (<any>response).error : undefined;

    let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
    if (status === 200) {
      return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
        let result200: any = null;
        let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
        result200 = resultData200 ? ExternalAuthenticateResultModel.fromJS(resultData200) : new ExternalAuthenticateResultModel();
        return _observableOf(result200);
      }));
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
        return throwException("An unexpected server error occurred.", status, _responseText, _headers);
      }));
    }
    return _observableOf<ExternalAuthenticateResultModel>(<any>null);
  }
}

@Injectable()
export class UserServiceProxy {
  private http: HttpClient;
  private baseUrl: string;
  protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

  constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
    this.http = http;
    this.baseUrl = baseUrl ? baseUrl : "";
  }

  /**
   * @input (optional)
   * @return Success
   */
  create(input: CreateUserDto | null | undefined): Observable<UserDto> {
    let url_ = this.baseUrl + "/api/services/app/User/Create";
    url_ = url_.replace(/[?&]$/, "");

    const content_ = JSON.stringify(input);

    let options_ : any = {
      body: content_,
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({
        "Content-Type": "application/json",
        "Accept": "application/json"
      })
    };

    return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
      return this.processCreate(response_);
    })).pipe(_observableCatch((response_: any) => {
      if (response_ instanceof HttpResponseBase) {
        try {
          return this.processCreate(<any>response_);
        } catch (e) {
          return <Observable<UserDto>><any>_observableThrow(e);
        }
      } else
        return <Observable<UserDto>><any>_observableThrow(response_);
    }));
  }

  protected processCreate(response: HttpResponseBase): Observable<UserDto> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse ? response.body :
        (<any>response).error instanceof Blob ? (<any>response).error : undefined;

    let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
    if (status === 200) {
      return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
        let result200: any = null;
        let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
        result200 = resultData200 ? UserDto.fromJS(resultData200) : new UserDto();
        return _observableOf(result200);
      }));
    } else if (status === 401) {
      return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
        return throwException("A server error occurred.", status, _responseText, _headers);
      }));
    } else if (status === 403) {
      return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
        return throwException("A server error occurred.", status, _responseText, _headers);
      }));
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
        return throwException("An unexpected server error occurred.", status, _responseText, _headers);
      }));
    }
    return _observableOf<UserDto>(<any>null);
  }

  /**
   * @input (optional)
   * @return Success
   */
  update(input: UserDto | null | undefined): Observable<UserDto> {
    let url_ = this.baseUrl + "/api/services/app/User/Update";
    url_ = url_.replace(/[?&]$/, "");

    const content_ = JSON.stringify(input);

    let options_ : any = {
      body: content_,
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({
        "Content-Type": "application/json",
        "Accept": "application/json"
      })
    };

    return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
      return this.processUpdate(response_);
    })).pipe(_observableCatch((response_: any) => {
      if (response_ instanceof HttpResponseBase) {
        try {
          return this.processUpdate(<any>response_);
        } catch (e) {
          return <Observable<UserDto>><any>_observableThrow(e);
        }
      } else
        return <Observable<UserDto>><any>_observableThrow(response_);
    }));
  }

  protected processUpdate(response: HttpResponseBase): Observable<UserDto> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse ? response.body :
        (<any>response).error instanceof Blob ? (<any>response).error : undefined;

    let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
    if (status === 200) {
      return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
        let result200: any = null;
        let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
        result200 = resultData200 ? UserDto.fromJS(resultData200) : new UserDto();
        return _observableOf(result200);
      }));
    } else if (status === 401) {
      return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
        return throwException("A server error occurred.", status, _responseText, _headers);
      }));
    } else if (status === 403) {
      return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
        return throwException("A server error occurred.", status, _responseText, _headers);
      }));
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
        return throwException("An unexpected server error occurred.", status, _responseText, _headers);
      }));
    }
    return _observableOf<UserDto>(<any>null);
  }

  /**
   * @id (optional)
   * @return Success
   */
  delete(id: number | null | undefined): Observable<void> {
    let url_ = this.baseUrl + "/api/services/app/User/Delete?";
    if (id !== undefined)
      url_ += "Id=" + encodeURIComponent("" + id) + "&";
    url_ = url_.replace(/[?&]$/, "");

    let options_ : any = {
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({
        "Content-Type": "application/json",
      })
    };

    return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
      return this.processDelete(response_);
    })).pipe(_observableCatch((response_: any) => {
      if (response_ instanceof HttpResponseBase) {
        try {
          return this.processDelete(<any>response_);
        } catch (e) {
          return <Observable<void>><any>_observableThrow(e);
        }
      } else
        return <Observable<void>><any>_observableThrow(response_);
    }));
  }

  protected processDelete(response: HttpResponseBase): Observable<void> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse ? response.body :
        (<any>response).error instanceof Blob ? (<any>response).error : undefined;

    let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
    if (status === 200) {
      return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
        return _observableOf<void>(<any>null);
      }));
    } else if (status === 401) {
      return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
        return throwException("A server error occurred.", status, _responseText, _headers);
      }));
    } else if (status === 403) {
      return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
        return throwException("A server error occurred.", status, _responseText, _headers);
      }));
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
        return throwException("An unexpected server error occurred.", status, _responseText, _headers);
      }));
    }
    return _observableOf<void>(<any>null);
  }

  /**
   * @return Success
   */
  getRoles(): Observable<ListResultDtoOfRoleDto> {
    let url_ = this.baseUrl + "/api/services/app/User/GetRoles";
    url_ = url_.replace(/[?&]$/, "");

    let options_ : any = {
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({
        "Content-Type": "application/json",
        "Accept": "application/json"
      })
    };

    return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
      return this.processGetRoles(response_);
    })).pipe(_observableCatch((response_: any) => {
      if (response_ instanceof HttpResponseBase) {
        try {
          return this.processGetRoles(<any>response_);
        } catch (e) {
          return <Observable<ListResultDtoOfRoleDto>><any>_observableThrow(e);
        }
      } else
        return <Observable<ListResultDtoOfRoleDto>><any>_observableThrow(response_);
    }));
  }

  protected processGetRoles(response: HttpResponseBase): Observable<ListResultDtoOfRoleDto> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse ? response.body :
        (<any>response).error instanceof Blob ? (<any>response).error : undefined;

    let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
    if (status === 200) {
      return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
        let result200: any = null;
        let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
        result200 = resultData200 ? ListResultDtoOfRoleDto.fromJS(resultData200) : new ListResultDtoOfRoleDto();
        return _observableOf(result200);
      }));
    } else if (status === 401) {
      return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
        return throwException("A server error occurred.", status, _responseText, _headers);
      }));
    } else if (status === 403) {
      return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
        return throwException("A server error occurred.", status, _responseText, _headers);
      }));
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
        return throwException("An unexpected server error occurred.", status, _responseText, _headers);
      }));
    }
    return _observableOf<ListResultDtoOfRoleDto>(<any>null);
  }

  /**
   * @input (optional)
   * @return Success
   */
  changeLanguage(input: ChangeUserLanguageDto | null | undefined): Observable<void> {
    let url_ = this.baseUrl + "/api/services/app/User/ChangeLanguage";
    url_ = url_.replace(/[?&]$/, "");

    const content_ = JSON.stringify(input);

    let options_ : any = {
      body: content_,
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({
        "Content-Type": "application/json",
      })
    };

    return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
      return this.processChangeLanguage(response_);
    })).pipe(_observableCatch((response_: any) => {
      if (response_ instanceof HttpResponseBase) {
        try {
          return this.processChangeLanguage(<any>response_);
        } catch (e) {
          return <Observable<void>><any>_observableThrow(e);
        }
      } else
        return <Observable<void>><any>_observableThrow(response_);
    }));
  }

  protected processChangeLanguage(response: HttpResponseBase): Observable<void> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse ? response.body :
        (<any>response).error instanceof Blob ? (<any>response).error : undefined;

    let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
    if (status === 200) {
      return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
        return _observableOf<void>(<any>null);
      }));
    } else if (status === 401) {
      return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
        return throwException("A server error occurred.", status, _responseText, _headers);
      }));
    } else if (status === 403) {
      return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
        return throwException("A server error occurred.", status, _responseText, _headers);
      }));
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
        return throwException("An unexpected server error occurred.", status, _responseText, _headers);
      }));
    }
    return _observableOf<void>(<any>null);
  }

  /**
   * @id (optional)
   * @return Success
   */
  get(id: number | null | undefined): Observable<UserDto> {
    let url_ = this.baseUrl + "/api/services/app/User/Get?";
    if (id !== undefined)
      url_ += "Id=" + encodeURIComponent("" + id) + "&";
    url_ = url_.replace(/[?&]$/, "");

    let options_ : any = {
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({
        "Content-Type": "application/json",
        "Accept": "application/json"
      })
    };

    return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
      return this.processGet(response_);
    })).pipe(_observableCatch((response_: any) => {
      if (response_ instanceof HttpResponseBase) {
        try {
          return this.processGet(<any>response_);
        } catch (e) {
          return <Observable<UserDto>><any>_observableThrow(e);
        }
      } else
        return <Observable<UserDto>><any>_observableThrow(response_);
    }));
  }

  protected processGet(response: HttpResponseBase): Observable<UserDto> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse ? response.body :
        (<any>response).error instanceof Blob ? (<any>response).error : undefined;

    let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
    if (status === 200) {
      return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
        let result200: any = null;
        let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
        result200 = resultData200 ? UserDto.fromJS(resultData200) : new UserDto();
        return _observableOf(result200);
      }));
    } else if (status === 401) {
      return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
        return throwException("A server error occurred.", status, _responseText, _headers);
      }));
    } else if (status === 403) {
      return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
        return throwException("A server error occurred.", status, _responseText, _headers);
      }));
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
        return throwException("An unexpected server error occurred.", status, _responseText, _headers);
      }));
    }
    return _observableOf<UserDto>(<any>null);
  }

  /**
   * @skipCount (optional)
   * @maxResultCount (optional)
   * @return Success
   */
  getAll(skipCount: number | null | undefined, maxResultCount: number | null | undefined): Observable<PagedResultDtoOfUserDto> {
    let url_ = this.baseUrl + "/api/services/app/User/GetAll?";
    if (skipCount !== undefined)
      url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
    if (maxResultCount !== undefined)
      url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
    url_ = url_.replace(/[?&]$/, "");

    let options_ : any = {
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({
        "Content-Type": "application/json",
        "Accept": "application/json"
      })
    };

    return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
      return this.processGetAll(response_);
    })).pipe(_observableCatch((response_: any) => {
      if (response_ instanceof HttpResponseBase) {
        try {
          return this.processGetAll(<any>response_);
        } catch (e) {
          return <Observable<PagedResultDtoOfUserDto>><any>_observableThrow(e);
        }
      } else
        return <Observable<PagedResultDtoOfUserDto>><any>_observableThrow(response_);
    }));
  }

  protected processGetAll(response: HttpResponseBase): Observable<PagedResultDtoOfUserDto> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse ? response.body :
        (<any>response).error instanceof Blob ? (<any>response).error : undefined;

    let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
    if (status === 200) {
      return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
        let result200: any = null;
        let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
        result200 = resultData200 ? PagedResultDtoOfUserDto.fromJS(resultData200) : new PagedResultDtoOfUserDto();
        return _observableOf(result200);
      }));
    } else if (status === 401) {
      return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
        return throwException("A server error occurred.", status, _responseText, _headers);
      }));
    } else if (status === 403) {
      return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
        return throwException("A server error occurred.", status, _responseText, _headers);
      }));
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
        return throwException("An unexpected server error occurred.", status, _responseText, _headers);
      }));
    }
    return _observableOf<PagedResultDtoOfUserDto>(<any>null);
  }
}

export class IsTenantAvailableInput implements IIsTenantAvailableInput {
  tenancyName: string;

  constructor(data?: IIsTenantAvailableInput) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(data?: any) {
    if (data) {
      this.tenancyName = data["tenancyName"];
    }
  }

  static fromJS(data: any): IsTenantAvailableInput {
    data = typeof data === 'object' ? data : {};
    let result = new IsTenantAvailableInput();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data["tenancyName"] = this.tenancyName;
    return data;
  }

  clone(): IsTenantAvailableInput {
    const json = this.toJSON();
    let result = new IsTenantAvailableInput();
    result.init(json);
    return result;
  }
}

export interface IIsTenantAvailableInput {
  tenancyName: string;
}

export class IsTenantAvailableOutput implements IIsTenantAvailableOutput {
  state: IsTenantAvailableOutputState | undefined;
  tenantId: number | undefined;

  constructor(data?: IIsTenantAvailableOutput) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(data?: any) {
    if (data) {
      this.state = data["state"];
      this.tenantId = data["tenantId"];
    }
  }

  static fromJS(data: any): IsTenantAvailableOutput {
    data = typeof data === 'object' ? data : {};
    let result = new IsTenantAvailableOutput();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data["state"] = this.state;
    data["tenantId"] = this.tenantId;
    return data;
  }

  clone(): IsTenantAvailableOutput {
    const json = this.toJSON();
    let result = new IsTenantAvailableOutput();
    result.init(json);
    return result;
  }
}

export interface IIsTenantAvailableOutput {
  state: IsTenantAvailableOutputState | undefined;
  tenantId: number | undefined;
}

export class RegisterInput implements IRegisterInput {
  name: string;
  surname: string;
  userName: string;
  emailAddress: string;
  password: string;
  captchaResponse: string | undefined;

  constructor(data?: IRegisterInput) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(data?: any) {
    if (data) {
      this.name = data["name"];
      this.surname = data["surname"];
      this.userName = data["userName"];
      this.emailAddress = data["emailAddress"];
      this.password = data["password"];
      this.captchaResponse = data["captchaResponse"];
    }
  }

  static fromJS(data: any): RegisterInput {
    data = typeof data === 'object' ? data : {};
    let result = new RegisterInput();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data["name"] = this.name;
    data["surname"] = this.surname;
    data["userName"] = this.userName;
    data["emailAddress"] = this.emailAddress;
    data["password"] = this.password;
    data["captchaResponse"] = this.captchaResponse;
    return data;
  }

  clone(): RegisterInput {
    const json = this.toJSON();
    let result = new RegisterInput();
    result.init(json);
    return result;
  }
}

export interface IRegisterInput {
  name: string;
  surname: string;
  userName: string;
  emailAddress: string;
  password: string;
  captchaResponse: string | undefined;
}

export class RegisterOutput implements IRegisterOutput {
  canLogin: boolean | undefined;

  constructor(data?: IRegisterOutput) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(data?: any) {
    if (data) {
      this.canLogin = data["canLogin"];
    }
  }

  static fromJS(data: any): RegisterOutput {
    data = typeof data === 'object' ? data : {};
    let result = new RegisterOutput();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data["canLogin"] = this.canLogin;
    return data;
  }

  clone(): RegisterOutput {
    const json = this.toJSON();
    let result = new RegisterOutput();
    result.init(json);
    return result;
  }
}

export interface IRegisterOutput {
  canLogin: boolean | undefined;
}

export class ChangeUiThemeInput implements IChangeUiThemeInput {
  theme: string;

  constructor(data?: IChangeUiThemeInput) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(data?: any) {
    if (data) {
      this.theme = data["theme"];
    }
  }

  static fromJS(data: any): ChangeUiThemeInput {
    data = typeof data === 'object' ? data : {};
    let result = new ChangeUiThemeInput();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data["theme"] = this.theme;
    return data;
  }

  clone(): ChangeUiThemeInput {
    const json = this.toJSON();
    let result = new ChangeUiThemeInput();
    result.init(json);
    return result;
  }
}

export interface IChangeUiThemeInput {
  theme: string;
}

export class CreateDeviceDto implements ICreateDeviceDto {
  deviceName: string;
  deviceCode: string;
  isActive: boolean | undefined;
  deviceDecription: string | undefined;
  dataSourceName: string[] | undefined;

  constructor(data?: ICreateDeviceDto) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(data?: any) {
    if (data) {
      this.deviceName = data["deviceName"];
      this.deviceCode = data["deviceCode"];
      this.isActive = data["isActive"];
      this.deviceDecription = data["deviceDecription"];
      if (data["dataSourceName"] && data["dataSourceName"].constructor === Array) {
        this.dataSourceName = [];
        for (let item of data["dataSourceName"])
          this.dataSourceName.push(item);
      }
    }
  }

  static fromJS(data: any): CreateDeviceDto {
    data = typeof data === 'object' ? data : {};
    let result = new CreateDeviceDto();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data["deviceName"] = this.deviceName;
    data["deviceCode"] = this.deviceCode;
    data["isActive"] = this.isActive;
    data["deviceDecription"] = this.deviceDecription;
    if (this.dataSourceName && this.dataSourceName.constructor === Array) {
      data["dataSourceName"] = [];
      for (let item of this.dataSourceName)
        data["dataSourceName"].push(item);
    }
    return data;
  }

  clone(): CreateDeviceDto {
    const json = this.toJSON();
    let result = new CreateDeviceDto();
    result.init(json);
    return result;
  }
}

export interface ICreateDeviceDto {
  deviceName: string;
  deviceCode: string;
  isActive: boolean | undefined;
  deviceDecription: string | undefined;
  dataSourceName: string[] | undefined;
}

export class DeviceDto implements IDeviceDto {
  deviceName: string;
  deviceCode: string;
  dataSourceID: string | undefined;
  isActive: boolean | undefined;
  deviceDecription: string | undefined;
  creationTime: moment.Moment | undefined;
  lastModificationTime: moment.Moment | undefined;
  id: number | undefined;

  constructor(data?: IDeviceDto) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(data?: any) {
    if (data) {
      this.deviceName = data["deviceName"];
      this.deviceCode = data["deviceCode"];
      this.dataSourceID = data["dataSourceID"];
      this.isActive = data["isActive"];
      this.deviceDecription = data["deviceDecription"];
      this.creationTime = data["creationTime"] ? moment(data["creationTime"].toString()) : <any>undefined;
      this.lastModificationTime = data["lastModificationTime"] ? moment(data["lastModificationTime"].toString()) : <any>undefined;
      this.id = data["id"];
    }
  }

  static fromJS(data: any): DeviceDto {
    data = typeof data === 'object' ? data : {};
    let result = new DeviceDto();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data["deviceName"] = this.deviceName;
    data["deviceCode"] = this.deviceCode;
    data["dataSourceID"] = this.dataSourceID;
    data["isActive"] = this.isActive;
    data["deviceDecription"] = this.deviceDecription;
    data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
    data["lastModificationTime"] = this.lastModificationTime ? this.lastModificationTime.toISOString() : <any>undefined;
    data["id"] = this.id;
    return data;
  }

  clone(): DeviceDto {
    const json = this.toJSON();
    let result = new DeviceDto();
    result.init(json);
    return result;
  }
}

export interface IDeviceDto {
  deviceName: string;
  deviceCode: string;
  dataSourceID: string | undefined;
  isActive: boolean | undefined;
  deviceDecription: string | undefined;
  creationTime: moment.Moment | undefined;
  lastModificationTime: moment.Moment | undefined;
  id: number | undefined;
}

export class PagedResultDtoOfDeviceDto implements IPagedResultDtoOfDeviceDto {
  totalCount: number | undefined;
  items: DeviceDto[] | undefined;

  constructor(data?: IPagedResultDtoOfDeviceDto) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(data?: any) {
    if (data) {
      this.totalCount = data["totalCount"];
      if (data["items"] && data["items"].constructor === Array) {
        this.items = [];
        for (let item of data["items"])
          this.items.push(DeviceDto.fromJS(item));
      }
    }
  }

  static fromJS(data: any): PagedResultDtoOfDeviceDto {
    data = typeof data === 'object' ? data : {};
    let result = new PagedResultDtoOfDeviceDto();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data["totalCount"] = this.totalCount;
    if (this.items && this.items.constructor === Array) {
      data["items"] = [];
      for (let item of this.items)
        data["items"].push(item.toJSON());
    }
    return data;
  }

  clone(): PagedResultDtoOfDeviceDto {
    const json = this.toJSON();
    let result = new PagedResultDtoOfDeviceDto();
    result.init(json);
    return result;
  }
}

export interface IPagedResultDtoOfDeviceDto {
  totalCount: number | undefined;
  items: DeviceDto[] | undefined;
}

export class CreateDeviceDataItemDto implements ICreateDeviceDataItemDto {
  deviceDataItemName: string | undefined;
  deviceDataDisplayName: string | undefined;
  deviceDataItemDescription: string | undefined;
  deviceDataItemLen: number | undefined;
  deviceDataItemType: string | undefined;

  constructor(data?: ICreateDeviceDataItemDto) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(data?: any) {
    if (data) {
      this.deviceDataItemName = data["deviceDataItemName"];
      this.deviceDataDisplayName = data["deviceDataDisplayName"];
      this.deviceDataItemDescription = data["deviceDataItemDescription"];
      this.deviceDataItemLen = data["deviceDataItemLen"];
      this.deviceDataItemType = data["deviceDataItemType"];
    }
  }

  static fromJS(data: any): CreateDeviceDataItemDto {
    data = typeof data === 'object' ? data : {};
    let result = new CreateDeviceDataItemDto();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data["deviceDataItemName"] = this.deviceDataItemName;
    data["deviceDataDisplayName"] = this.deviceDataDisplayName;
    data["deviceDataItemDescription"] = this.deviceDataItemDescription;
    data["deviceDataItemLen"] = this.deviceDataItemLen;
    data["deviceDataItemType"] = this.deviceDataItemType;
    return data;
  }

  clone(): CreateDeviceDataItemDto {
    const json = this.toJSON();
    let result = new CreateDeviceDataItemDto();
    result.init(json);
    return result;
  }
}

export interface ICreateDeviceDataItemDto {
  deviceDataItemName: string | undefined;
  deviceDataDisplayName: string | undefined;
  deviceDataItemDescription: string | undefined;
  deviceDataItemLen: number | undefined;
  deviceDataItemType: string | undefined;
}

export class DeviceDataItemDto implements IDeviceDataItemDto {
  deviceDataItemName: string | undefined;
  deviceDataDisplayName: string | undefined;
  deviceDataItemDescription: string | undefined;
  deviceDataItemLen: number | undefined;
  deviceDataItemType: string | undefined;
  id: number | undefined;

  constructor(data?: IDeviceDataItemDto) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(data?: any) {
    if (data) {
      this.deviceDataItemName = data["deviceDataItemName"];
      this.deviceDataDisplayName = data["deviceDataDisplayName"];
      this.deviceDataItemDescription = data["deviceDataItemDescription"];
      this.deviceDataItemLen = data["deviceDataItemLen"];
      this.deviceDataItemType = data["deviceDataItemType"];
      this.id = data["id"];
    }
  }

  static fromJS(data: any): DeviceDataItemDto {
    data = typeof data === 'object' ? data : {};
    let result = new DeviceDataItemDto();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data["deviceDataItemName"] = this.deviceDataItemName;
    data["deviceDataDisplayName"] = this.deviceDataDisplayName;
    data["deviceDataItemDescription"] = this.deviceDataItemDescription;
    data["deviceDataItemLen"] = this.deviceDataItemLen;
    data["deviceDataItemType"] = this.deviceDataItemType;
    data["id"] = this.id;
    return data;
  }

  clone(): DeviceDataItemDto {
    const json = this.toJSON();
    let result = new DeviceDataItemDto();
    result.init(json);
    return result;
  }
}

export interface IDeviceDataItemDto {
  deviceDataItemName: string | undefined;
  deviceDataDisplayName: string | undefined;
  deviceDataItemDescription: string | undefined;
  deviceDataItemLen: number | undefined;
  deviceDataItemType: string | undefined;
  id: number | undefined;
}

export class PagedResultDtoOfDeviceDataItemDto implements IPagedResultDtoOfDeviceDataItemDto {
  totalCount: number | undefined;
  items: DeviceDataItemDto[] | undefined;

  constructor(data?: IPagedResultDtoOfDeviceDataItemDto) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(data?: any) {
    if (data) {
      this.totalCount = data["totalCount"];
      if (data["items"] && data["items"].constructor === Array) {
        this.items = [];
        for (let item of data["items"])
          this.items.push(DeviceDataItemDto.fromJS(item));
      }
    }
  }

  static fromJS(data: any): PagedResultDtoOfDeviceDataItemDto {
    data = typeof data === 'object' ? data : {};
    let result = new PagedResultDtoOfDeviceDataItemDto();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data["totalCount"] = this.totalCount;
    if (this.items && this.items.constructor === Array) {
      data["items"] = [];
      for (let item of this.items)
        data["items"].push(item.toJSON());
    }
    return data;
  }

  clone(): PagedResultDtoOfDeviceDataItemDto {
    const json = this.toJSON();
    let result = new PagedResultDtoOfDeviceDataItemDto();
    result.init(json);
    return result;
  }
}

export interface IPagedResultDtoOfDeviceDataItemDto {
  totalCount: number | undefined;
  items: DeviceDataItemDto[] | undefined;
}

export class DeviceDataSourceDto implements IDeviceDataSourceDto {
  dataSourceName: string;
  dataSourceAddress: string;
  dataSourceType: string;
  dataSourceDescription: string | undefined;
  id: number | undefined;

  constructor(data?: IDeviceDataSourceDto) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(data?: any) {
    if (data) {
      this.dataSourceName = data["dataSourceName"];
      this.dataSourceAddress = data["dataSourceAddress"];
      this.dataSourceType = data["dataSourceType"];
      this.dataSourceDescription = data["dataSourceDescription"];
      this.id = data["id"];
    }
  }

  static fromJS(data: any): DeviceDataSourceDto {
    data = typeof data === 'object' ? data : {};
    let result = new DeviceDataSourceDto();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data["dataSourceName"] = this.dataSourceName;
    data["dataSourceAddress"] = this.dataSourceAddress;
    data["dataSourceType"] = this.dataSourceType;
    data["dataSourceDescription"] = this.dataSourceDescription;
    data["id"] = this.id;
    return data;
  }

  clone(): DeviceDataSourceDto {
    const json = this.toJSON();
    let result = new DeviceDataSourceDto();
    result.init(json);
    return result;
  }
}

export interface IDeviceDataSourceDto {
  dataSourceName: string;
  dataSourceAddress: string;
  dataSourceType: string;
  dataSourceDescription: string | undefined;
  id: number | undefined;
}

export class PagedResultDtoOfDeviceDataSourceDto implements IPagedResultDtoOfDeviceDataSourceDto {
  totalCount: number | undefined;
  items: DeviceDataSourceDto[] | undefined;

  constructor(data?: IPagedResultDtoOfDeviceDataSourceDto) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(data?: any) {
    if (data) {
      this.totalCount = data["totalCount"];
      if (data["items"] && data["items"].constructor === Array) {
        this.items = [];
        for (let item of data["items"])
          this.items.push(DeviceDataSourceDto.fromJS(item));
      }
    }
  }

  static fromJS(data: any): PagedResultDtoOfDeviceDataSourceDto {
    data = typeof data === 'object' ? data : {};
    let result = new PagedResultDtoOfDeviceDataSourceDto();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data["totalCount"] = this.totalCount;
    if (this.items && this.items.constructor === Array) {
      data["items"] = [];
      for (let item of this.items)
        data["items"].push(item.toJSON());
    }
    return data;
  }

  clone(): PagedResultDtoOfDeviceDataSourceDto {
    const json = this.toJSON();
    let result = new PagedResultDtoOfDeviceDataSourceDto();
    result.init(json);
    return result;
  }
}

export interface IPagedResultDtoOfDeviceDataSourceDto {
  totalCount: number | undefined;
  items: DeviceDataSourceDto[] | undefined;
}

export class CreateDeviceDataSourceDto implements ICreateDeviceDataSourceDto {
  dataSourceName: string;
  dataSourceAddress: string;
  dataSourceType: string;
  dataSourceDescription: string | undefined;

  constructor(data?: ICreateDeviceDataSourceDto) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(data?: any) {
    if (data) {
      this.dataSourceName = data["dataSourceName"];
      this.dataSourceAddress = data["dataSourceAddress"];
      this.dataSourceType = data["dataSourceType"];
      this.dataSourceDescription = data["dataSourceDescription"];
    }
  }

  static fromJS(data: any): CreateDeviceDataSourceDto {
    data = typeof data === 'object' ? data : {};
    let result = new CreateDeviceDataSourceDto();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data["dataSourceName"] = this.dataSourceName;
    data["dataSourceAddress"] = this.dataSourceAddress;
    data["dataSourceType"] = this.dataSourceType;
    data["dataSourceDescription"] = this.dataSourceDescription;
    return data;
  }

  clone(): CreateDeviceDataSourceDto {
    const json = this.toJSON();
    let result = new CreateDeviceDataSourceDto();
    result.init(json);
    return result;
  }
}

export interface ICreateDeviceDataSourceDto {
  dataSourceName: string;
  dataSourceAddress: string;
  dataSourceType: string;
  dataSourceDescription: string | undefined;
}

export class CreateDeviceDataValueDto implements ICreateDeviceDataValueDto {
  deviceDataItemDeviceID: number | undefined;
  productionLineDeviceID: number | undefined;
  dataValue: string | undefined;
  creationTime: moment.Moment | undefined;
  deviceDataItemName: string | undefined;
  id: string | undefined;

  constructor(data?: ICreateDeviceDataValueDto) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(data?: any) {
    if (data) {
      this.deviceDataItemDeviceID = data["deviceDataItemDeviceID"];
      this.productionLineDeviceID = data["productionLineDeviceID"];
      this.dataValue = data["dataValue"];
      this.creationTime = data["creationTime"] ? moment(data["creationTime"].toString()) : <any>undefined;
      this.deviceDataItemName = data["deviceDataItemName"];
      this.id = data["id"];
    }
  }

  static fromJS(data: any): CreateDeviceDataValueDto {
    data = typeof data === 'object' ? data : {};
    let result = new CreateDeviceDataValueDto();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data["deviceDataItemDeviceID"] = this.deviceDataItemDeviceID;
    data["productionLineDeviceID"] = this.productionLineDeviceID;
    data["dataValue"] = this.dataValue;
    data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
    data["deviceDataItemName"] = this.deviceDataItemName;
    data["id"] = this.id;
    return data;
  }

  clone(): CreateDeviceDataValueDto {
    const json = this.toJSON();
    let result = new CreateDeviceDataValueDto();
    result.init(json);
    return result;
  }
}

export interface ICreateDeviceDataValueDto {
  deviceDataItemDeviceID: number | undefined;
  productionLineDeviceID: number | undefined;
  dataValue: string | undefined;
  creationTime: moment.Moment | undefined;
  deviceDataItemName: string | undefined;
  id: string | undefined;
}

export class DeviceDataValueDto implements IDeviceDataValueDto {
  deviceDataItemDeviceID: number | undefined;
  productionLineDeviceID: number | undefined;
  dataValue: string | undefined;
  creationTime: moment.Moment | undefined;
  deviceDataItemName: string | undefined;
  id: string | undefined;

  constructor(data?: IDeviceDataValueDto) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(data?: any) {
    if (data) {
      this.deviceDataItemDeviceID = data["deviceDataItemDeviceID"];
      this.productionLineDeviceID = data["productionLineDeviceID"];
      this.dataValue = data["dataValue"];
      this.creationTime = data["creationTime"] ? moment(data["creationTime"].toString()) : <any>undefined;
      this.deviceDataItemName = data["deviceDataItemName"];
      this.id = data["id"];
    }
  }

  static fromJS(data: any): DeviceDataValueDto {
    data = typeof data === 'object' ? data : {};
    let result = new DeviceDataValueDto();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data["deviceDataItemDeviceID"] = this.deviceDataItemDeviceID;
    data["productionLineDeviceID"] = this.productionLineDeviceID;
    data["dataValue"] = this.dataValue;
    data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
    data["deviceDataItemName"] = this.deviceDataItemName;
    data["id"] = this.id;
    return data;
  }

  clone(): DeviceDataValueDto {
    const json = this.toJSON();
    let result = new DeviceDataValueDto();
    result.init(json);
    return result;
  }
}

export interface IDeviceDataValueDto {
  deviceDataItemDeviceID: number | undefined;
  productionLineDeviceID: number | undefined;
  dataValue: string | undefined;
  creationTime: moment.Moment | undefined;
  deviceDataItemName: string | undefined;
  id: string | undefined;
}

export class DeviceInfoAndDataDto implements IDeviceInfoAndDataDto {
  deviceID: number | undefined;
  deviceName: string | undefined;
  deviceCode: string | undefined;
  deviceDataValueDtos: DeviceDataValueDto[] | undefined;

  constructor(data?: IDeviceInfoAndDataDto) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(data?: any) {
    if (data) {
      this.deviceID = data["deviceID"];
      this.deviceName = data["deviceName"];
      this.deviceCode = data["deviceCode"];
      if (data["deviceDataValueDtos"] && data["deviceDataValueDtos"].constructor === Array) {
        this.deviceDataValueDtos = [];
        for (let item of data["deviceDataValueDtos"])
          this.deviceDataValueDtos.push(DeviceDataValueDto.fromJS(item));
      }
    }
  }

  static fromJS(data: any): DeviceInfoAndDataDto {
    data = typeof data === 'object' ? data : {};
    let result = new DeviceInfoAndDataDto();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data["deviceID"] = this.deviceID;
    data["deviceName"] = this.deviceName;
    data["deviceCode"] = this.deviceCode;
    if (this.deviceDataValueDtos && this.deviceDataValueDtos.constructor === Array) {
      data["deviceDataValueDtos"] = [];
      for (let item of this.deviceDataValueDtos)
        data["deviceDataValueDtos"].push(item.toJSON());
    }
    return data;
  }

  clone(): DeviceInfoAndDataDto {
    const json = this.toJSON();
    let result = new DeviceInfoAndDataDto();
    result.init(json);
    return result;
  }
}

export interface IDeviceInfoAndDataDto {
  deviceID: number | undefined;
  deviceName: string | undefined;
  deviceCode: string | undefined;
  deviceDataValueDtos: DeviceDataValueDto[] | undefined;
}

export class YaJiPinLvDto implements IYaJiPinLvDto {
  title: string | undefined;
  value: string | undefined;

  constructor(data?: IYaJiPinLvDto) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(data?: any) {
    if (data) {
      this.title = data["title"];
      this.value = data["value"];
    }
  }

  static fromJS(data: any): YaJiPinLvDto {
    data = typeof data === 'object' ? data : {};
    let result = new YaJiPinLvDto();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data["title"] = this.title;
    data["value"] = this.value;
    return data;
  }

  clone(): YaJiPinLvDto {
    const json = this.toJSON();
    let result = new YaJiPinLvDto();
    result.init(json);
    return result;
  }
}

export interface IYaJiPinLvDto {
  title: string | undefined;
  value: string | undefined;
}

export class KeyParamValueDto implements IKeyParamValueDto {
  title: string | undefined;
  value: string | undefined;

  constructor(data?: IKeyParamValueDto) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(data?: any) {
    if (data) {
      this.title = data["title"];
      this.value = data["value"];
    }
  }

  static fromJS(data: any): KeyParamValueDto {
    data = typeof data === 'object' ? data : {};
    let result = new KeyParamValueDto();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data["title"] = this.title;
    data["value"] = this.value;
    return data;
  }

  clone(): KeyParamValueDto {
    const json = this.toJSON();
    let result = new KeyParamValueDto();
    result.init(json);
    return result;
  }
}

export interface IKeyParamValueDto {
  title: string | undefined;
  value: string | undefined;
}

export class PagedResultDtoOfDeviceDataValueDto implements IPagedResultDtoOfDeviceDataValueDto {
  totalCount: number | undefined;
  items: DeviceDataValueDto[] | undefined;

  constructor(data?: IPagedResultDtoOfDeviceDataValueDto) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(data?: any) {
    if (data) {
      this.totalCount = data["totalCount"];
      if (data["items"] && data["items"].constructor === Array) {
        this.items = [];
        for (let item of data["items"])
          this.items.push(DeviceDataValueDto.fromJS(item));
      }
    }
  }

  static fromJS(data: any): PagedResultDtoOfDeviceDataValueDto {
    data = typeof data === 'object' ? data : {};
    let result = new PagedResultDtoOfDeviceDataValueDto();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data["totalCount"] = this.totalCount;
    if (this.items && this.items.constructor === Array) {
      data["items"] = [];
      for (let item of this.items)
        data["items"].push(item.toJSON());
    }
    return data;
  }

  clone(): PagedResultDtoOfDeviceDataValueDto {
    const json = this.toJSON();
    let result = new PagedResultDtoOfDeviceDataValueDto();
    result.init(json);
    return result;
  }
}

export interface IPagedResultDtoOfDeviceDataValueDto {
  totalCount: number | undefined;
  items: DeviceDataValueDto[] | undefined;
}

export class CreateEnterpriseDto implements ICreateEnterpriseDto {
  enterpriseName: string | undefined;
  enterpriseDescription: string | undefined;
  id: number | undefined;

  constructor(data?: ICreateEnterpriseDto) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(data?: any) {
    if (data) {
      this.enterpriseName = data["enterpriseName"];
      this.enterpriseDescription = data["enterpriseDescription"];
      this.id = data["id"];
    }
  }

  static fromJS(data: any): CreateEnterpriseDto {
    data = typeof data === 'object' ? data : {};
    let result = new CreateEnterpriseDto();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data["enterpriseName"] = this.enterpriseName;
    data["enterpriseDescription"] = this.enterpriseDescription;
    data["id"] = this.id;
    return data;
  }

  clone(): CreateEnterpriseDto {
    const json = this.toJSON();
    let result = new CreateEnterpriseDto();
    result.init(json);
    return result;
  }
}

export interface ICreateEnterpriseDto {
  enterpriseName: string | undefined;
  enterpriseDescription: string | undefined;
  id: number | undefined;
}

export class EnterpriseDto implements IEnterpriseDto {
  enterpriseName: string | undefined;
  enterpriseDescription: string | undefined;
  creationTime: moment.Moment | undefined;
  id: number | undefined;

  constructor(data?: IEnterpriseDto) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(data?: any) {
    if (data) {
      this.enterpriseName = data["enterpriseName"];
      this.enterpriseDescription = data["enterpriseDescription"];
      this.creationTime = data["creationTime"] ? moment(data["creationTime"].toString()) : <any>undefined;
      this.id = data["id"];
    }
  }

  static fromJS(data: any): EnterpriseDto {
    data = typeof data === 'object' ? data : {};
    let result = new EnterpriseDto();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data["enterpriseName"] = this.enterpriseName;
    data["enterpriseDescription"] = this.enterpriseDescription;
    data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
    data["id"] = this.id;
    return data;
  }

  clone(): EnterpriseDto {
    const json = this.toJSON();
    let result = new EnterpriseDto();
    result.init(json);
    return result;
  }
}

export interface IEnterpriseDto {
  enterpriseName: string | undefined;
  enterpriseDescription: string | undefined;
  creationTime: moment.Moment | undefined;
  id: number | undefined;
}

export class PagedResultDtoOfEnterpriseDto implements IPagedResultDtoOfEnterpriseDto {
  totalCount: number | undefined;
  items: EnterpriseDto[] | undefined;

  constructor(data?: IPagedResultDtoOfEnterpriseDto) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(data?: any) {
    if (data) {
      this.totalCount = data["totalCount"];
      if (data["items"] && data["items"].constructor === Array) {
        this.items = [];
        for (let item of data["items"])
          this.items.push(EnterpriseDto.fromJS(item));
      }
    }
  }

  static fromJS(data: any): PagedResultDtoOfEnterpriseDto {
    data = typeof data === 'object' ? data : {};
    let result = new PagedResultDtoOfEnterpriseDto();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data["totalCount"] = this.totalCount;
    if (this.items && this.items.constructor === Array) {
      data["items"] = [];
      for (let item of this.items)
        data["items"].push(item.toJSON());
    }
    return data;
  }

  clone(): PagedResultDtoOfEnterpriseDto {
    const json = this.toJSON();
    let result = new PagedResultDtoOfEnterpriseDto();
    result.init(json);
    return result;
  }
}

export interface IPagedResultDtoOfEnterpriseDto {
  totalCount: number | undefined;
  items: EnterpriseDto[] | undefined;
}

export class CreateFactoryDto implements ICreateFactoryDto {
  factoryName: string | undefined;
  factoryDescription: string | undefined;
  id: number | undefined;

  constructor(data?: ICreateFactoryDto) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(data?: any) {
    if (data) {
      this.factoryName = data["factoryName"];
      this.factoryDescription = data["factoryDescription"];
      this.id = data["id"];
    }
  }

  static fromJS(data: any): CreateFactoryDto {
    data = typeof data === 'object' ? data : {};
    let result = new CreateFactoryDto();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data["factoryName"] = this.factoryName;
    data["factoryDescription"] = this.factoryDescription;
    data["id"] = this.id;
    return data;
  }

  clone(): CreateFactoryDto {
    const json = this.toJSON();
    let result = new CreateFactoryDto();
    result.init(json);
    return result;
  }
}

export interface ICreateFactoryDto {
  factoryName: string | undefined;
  factoryDescription: string | undefined;
  id: number | undefined;
}

export class FactoryDto implements IFactoryDto {
  factoryName: string | undefined;
  factoryDescription: string | undefined;
  creationTime: moment.Moment | undefined;
  id: number | undefined;

  constructor(data?: IFactoryDto) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(data?: any) {
    if (data) {
      this.factoryName = data["factoryName"];
      this.factoryDescription = data["factoryDescription"];
      this.creationTime = data["creationTime"] ? moment(data["creationTime"].toString()) : <any>undefined;
      this.id = data["id"];
    }
  }

  static fromJS(data: any): FactoryDto {
    data = typeof data === 'object' ? data : {};
    let result = new FactoryDto();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data["factoryName"] = this.factoryName;
    data["factoryDescription"] = this.factoryDescription;
    data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
    data["id"] = this.id;
    return data;
  }

  clone(): FactoryDto {
    const json = this.toJSON();
    let result = new FactoryDto();
    result.init(json);
    return result;
  }
}

export interface IFactoryDto {
  factoryName: string | undefined;
  factoryDescription: string | undefined;
  creationTime: moment.Moment | undefined;
  id: number | undefined;
}

export class PagedResultDtoOfFactoryDto implements IPagedResultDtoOfFactoryDto {
  totalCount: number | undefined;
  items: FactoryDto[] | undefined;

  constructor(data?: IPagedResultDtoOfFactoryDto) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(data?: any) {
    if (data) {
      this.totalCount = data["totalCount"];
      if (data["items"] && data["items"].constructor === Array) {
        this.items = [];
        for (let item of data["items"])
          this.items.push(FactoryDto.fromJS(item));
      }
    }
  }

  static fromJS(data: any): PagedResultDtoOfFactoryDto {
    data = typeof data === 'object' ? data : {};
    let result = new PagedResultDtoOfFactoryDto();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data["totalCount"] = this.totalCount;
    if (this.items && this.items.constructor === Array) {
      data["items"] = [];
      for (let item of this.items)
        data["items"].push(item.toJSON());
    }
    return data;
  }

  clone(): PagedResultDtoOfFactoryDto {
    const json = this.toJSON();
    let result = new PagedResultDtoOfFactoryDto();
    result.init(json);
    return result;
  }
}

export interface IPagedResultDtoOfFactoryDto {
  totalCount: number | undefined;
  items: FactoryDto[] | undefined;
}

export class CreateGroupDto implements ICreateGroupDto {
  groupName: string | undefined;
  groupDescription: string | undefined;
  id: number | undefined;

  constructor(data?: ICreateGroupDto) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(data?: any) {
    if (data) {
      this.groupName = data["groupName"];
      this.groupDescription = data["groupDescription"];
      this.id = data["id"];
    }
  }

  static fromJS(data: any): CreateGroupDto {
    data = typeof data === 'object' ? data : {};
    let result = new CreateGroupDto();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data["groupName"] = this.groupName;
    data["groupDescription"] = this.groupDescription;
    data["id"] = this.id;
    return data;
  }

  clone(): CreateGroupDto {
    const json = this.toJSON();
    let result = new CreateGroupDto();
    result.init(json);
    return result;
  }
}

export interface ICreateGroupDto {
  groupName: string | undefined;
  groupDescription: string | undefined;
  id: number | undefined;
}

export class GroupDto implements IGroupDto {
  groupName: string | undefined;
  groupDescription: string | undefined;
  creationTime: moment.Moment | undefined;
  id: number | undefined;

  constructor(data?: IGroupDto) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(data?: any) {
    if (data) {
      this.groupName = data["groupName"];
      this.groupDescription = data["groupDescription"];
      this.creationTime = data["creationTime"] ? moment(data["creationTime"].toString()) : <any>undefined;
      this.id = data["id"];
    }
  }

  static fromJS(data: any): GroupDto {
    data = typeof data === 'object' ? data : {};
    let result = new GroupDto();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data["groupName"] = this.groupName;
    data["groupDescription"] = this.groupDescription;
    data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
    data["id"] = this.id;
    return data;
  }

  clone(): GroupDto {
    const json = this.toJSON();
    let result = new GroupDto();
    result.init(json);
    return result;
  }
}

export interface IGroupDto {
  groupName: string | undefined;
  groupDescription: string | undefined;
  creationTime: moment.Moment | undefined;
  id: number | undefined;
}

export class PagedResultDtoOfGroupDto implements IPagedResultDtoOfGroupDto {
  totalCount: number | undefined;
  items: GroupDto[] | undefined;

  constructor(data?: IPagedResultDtoOfGroupDto) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(data?: any) {
    if (data) {
      this.totalCount = data["totalCount"];
      if (data["items"] && data["items"].constructor === Array) {
        this.items = [];
        for (let item of data["items"])
          this.items.push(GroupDto.fromJS(item));
      }
    }
  }

  static fromJS(data: any): PagedResultDtoOfGroupDto {
    data = typeof data === 'object' ? data : {};
    let result = new PagedResultDtoOfGroupDto();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data["totalCount"] = this.totalCount;
    if (this.items && this.items.constructor === Array) {
      data["items"] = [];
      for (let item of this.items)
        data["items"].push(item.toJSON());
    }
    return data;
  }

  clone(): PagedResultDtoOfGroupDto {
    const json = this.toJSON();
    let result = new PagedResultDtoOfGroupDto();
    result.init(json);
    return result;
  }
}

export interface IPagedResultDtoOfGroupDto {
  totalCount: number | undefined;
  items: GroupDto[] | undefined;
}

export class CreateProductionLineDto implements ICreateProductionLineDto {
  productionLineName: string | undefined;
  productionLineCode: string | undefined;
  productionLineDescription: string | undefined;
  id: number | undefined;

  constructor(data?: ICreateProductionLineDto) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(data?: any) {
    if (data) {
      this.productionLineName = data["productionLineName"];
      this.productionLineCode = data["productionLineCode"];
      this.productionLineDescription = data["productionLineDescription"];
      this.id = data["id"];
    }
  }

  static fromJS(data: any): CreateProductionLineDto {
    data = typeof data === 'object' ? data : {};
    let result = new CreateProductionLineDto();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data["productionLineName"] = this.productionLineName;
    data["productionLineCode"] = this.productionLineCode;
    data["productionLineDescription"] = this.productionLineDescription;
    data["id"] = this.id;
    return data;
  }

  clone(): CreateProductionLineDto {
    const json = this.toJSON();
    let result = new CreateProductionLineDto();
    result.init(json);
    return result;
  }
}

export interface ICreateProductionLineDto {
  productionLineName: string | undefined;
  productionLineCode: string | undefined;
  productionLineDescription: string | undefined;
  id: number | undefined;
}

export class ProductionLineDto implements IProductionLineDto {
  productionLineName: string | undefined;
  productionLineCode: string | undefined;
  productionLineDescription: string | undefined;
  creationTime: moment.Moment | undefined;
  lastModificationTime: moment.Moment | undefined;
  id: number | undefined;

  constructor(data?: IProductionLineDto) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(data?: any) {
    if (data) {
      this.productionLineName = data["productionLineName"];
      this.productionLineCode = data["productionLineCode"];
      this.productionLineDescription = data["productionLineDescription"];
      this.creationTime = data["creationTime"] ? moment(data["creationTime"].toString()) : <any>undefined;
      this.lastModificationTime = data["lastModificationTime"] ? moment(data["lastModificationTime"].toString()) : <any>undefined;
      this.id = data["id"];
    }
  }

  static fromJS(data: any): ProductionLineDto {
    data = typeof data === 'object' ? data : {};
    let result = new ProductionLineDto();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data["productionLineName"] = this.productionLineName;
    data["productionLineCode"] = this.productionLineCode;
    data["productionLineDescription"] = this.productionLineDescription;
    data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
    data["lastModificationTime"] = this.lastModificationTime ? this.lastModificationTime.toISOString() : <any>undefined;
    data["id"] = this.id;
    return data;
  }

  clone(): ProductionLineDto {
    const json = this.toJSON();
    let result = new ProductionLineDto();
    result.init(json);
    return result;
  }
}

export interface IProductionLineDto {
  productionLineName: string | undefined;
  productionLineCode: string | undefined;
  productionLineDescription: string | undefined;
  creationTime: moment.Moment | undefined;
  lastModificationTime: moment.Moment | undefined;
  id: number | undefined;
}

export class ProductionLineParamDto implements IProductionLineParamDto {
  productionLineName: string | undefined;
  productionLineID: number | undefined;
  prodcutionTotal: string | undefined;
  productionLineDeviceID: number | undefined;
  chanLiangJiShuID: number | undefined;
  productionLineDeviceParamDtos: ProductionLineDeviceParamDto[] | undefined;

  constructor(data?: IProductionLineParamDto) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(data?: any) {
    if (data) {
      this.productionLineName = data["productionLineName"];
      this.productionLineID = data["productionLineID"];
      this.prodcutionTotal = data["prodcutionTotal"];
      this.productionLineDeviceID = data["productionLineDeviceID"];
      this.chanLiangJiShuID = data["chanLiangJiShuID"];
      if (data["productionLineDeviceParamDtos"] && data["productionLineDeviceParamDtos"].constructor === Array) {
        this.productionLineDeviceParamDtos = [];
        for (let item of data["productionLineDeviceParamDtos"])
          this.productionLineDeviceParamDtos.push(ProductionLineDeviceParamDto.fromJS(item));
      }
    }
  }

  static fromJS(data: any): ProductionLineParamDto {
    data = typeof data === 'object' ? data : {};
    let result = new ProductionLineParamDto();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data["productionLineName"] = this.productionLineName;
    data["productionLineID"] = this.productionLineID;
    data["prodcutionTotal"] = this.prodcutionTotal;
    data["productionLineDeviceID"] = this.productionLineDeviceID;
    data["chanLiangJiShuID"] = this.chanLiangJiShuID;
    if (this.productionLineDeviceParamDtos && this.productionLineDeviceParamDtos.constructor === Array) {
      data["productionLineDeviceParamDtos"] = [];
      for (let item of this.productionLineDeviceParamDtos)
        data["productionLineDeviceParamDtos"].push(item.toJSON());
    }
    return data;
  }

  clone(): ProductionLineParamDto {
    const json = this.toJSON();
    let result = new ProductionLineParamDto();
    result.init(json);
    return result;
  }
}

export interface IProductionLineParamDto {
  productionLineName: string | undefined;
  productionLineID: number | undefined;
  prodcutionTotal: string | undefined;
  productionLineDeviceID: number | undefined;
  chanLiangJiShuID: number | undefined;
  productionLineDeviceParamDtos: ProductionLineDeviceParamDto[] | undefined;
}

export class ProductionLineDeviceParamDto implements IProductionLineDeviceParamDto {
  deviceName: string | undefined;
  deviceId: number | undefined;
  deviceValue: any | undefined;
  deviceItemType: string | undefined;
  productionLineDeviceID: number | undefined;
  deviceDataItemDeviceID: number | undefined;

  constructor(data?: IProductionLineDeviceParamDto) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(data?: any) {
    if (data) {
      this.deviceName = data["deviceName"];
      this.deviceId = data["deviceId"];
      this.deviceValue = data["deviceValue"];
      this.deviceItemType = data["deviceItemType"];
      this.productionLineDeviceID = data["productionLineDeviceID"];
      this.deviceDataItemDeviceID = data["deviceDataItemDeviceID"];
    }
  }

  static fromJS(data: any): ProductionLineDeviceParamDto {
    data = typeof data === 'object' ? data : {};
    let result = new ProductionLineDeviceParamDto();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data["deviceName"] = this.deviceName;
    data["deviceId"] = this.deviceId;
    data["deviceValue"] = this.deviceValue;
    data["deviceItemType"] = this.deviceItemType;
    data["productionLineDeviceID"] = this.productionLineDeviceID;
    data["deviceDataItemDeviceID"] = this.deviceDataItemDeviceID;
    return data;
  }

  clone(): ProductionLineDeviceParamDto {
    const json = this.toJSON();
    let result = new ProductionLineDeviceParamDto();
    result.init(json);
    return result;
  }
}

export interface IProductionLineDeviceParamDto {
  deviceName: string | undefined;
  deviceId: number | undefined;
  deviceValue: any | undefined;
  deviceItemType: string | undefined;
  productionLineDeviceID: number | undefined;
  deviceDataItemDeviceID: number | undefined;
}

export class PagedResultDtoOfProductionLineDto implements IPagedResultDtoOfProductionLineDto {
  totalCount: number | undefined;
  items: ProductionLineDto[] | undefined;

  constructor(data?: IPagedResultDtoOfProductionLineDto) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(data?: any) {
    if (data) {
      this.totalCount = data["totalCount"];
      if (data["items"] && data["items"].constructor === Array) {
        this.items = [];
        for (let item of data["items"])
          this.items.push(ProductionLineDto.fromJS(item));
      }
    }
  }

  static fromJS(data: any): PagedResultDtoOfProductionLineDto {
    data = typeof data === 'object' ? data : {};
    let result = new PagedResultDtoOfProductionLineDto();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data["totalCount"] = this.totalCount;
    if (this.items && this.items.constructor === Array) {
      data["items"] = [];
      for (let item of this.items)
        data["items"].push(item.toJSON());
    }
    return data;
  }

  clone(): PagedResultDtoOfProductionLineDto {
    const json = this.toJSON();
    let result = new PagedResultDtoOfProductionLineDto();
    result.init(json);
    return result;
  }
}

export interface IPagedResultDtoOfProductionLineDto {
  totalCount: number | undefined;
  items: ProductionLineDto[] | undefined;
}

export class CreateRoleDto implements ICreateRoleDto {
  name: string;
  displayName: string;
  normalizedName: string | undefined;
  description: string | undefined;
  isStatic: boolean | undefined;
  permissions: string[] | undefined;

  constructor(data?: ICreateRoleDto) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(data?: any) {
    if (data) {
      this.name = data["name"];
      this.displayName = data["displayName"];
      this.normalizedName = data["normalizedName"];
      this.description = data["description"];
      this.isStatic = data["isStatic"];
      if (data["permissions"] && data["permissions"].constructor === Array) {
        this.permissions = [];
        for (let item of data["permissions"])
          this.permissions.push(item);
      }
    }
  }

  static fromJS(data: any): CreateRoleDto {
    data = typeof data === 'object' ? data : {};
    let result = new CreateRoleDto();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data["name"] = this.name;
    data["displayName"] = this.displayName;
    data["normalizedName"] = this.normalizedName;
    data["description"] = this.description;
    data["isStatic"] = this.isStatic;
    if (this.permissions && this.permissions.constructor === Array) {
      data["permissions"] = [];
      for (let item of this.permissions)
        data["permissions"].push(item);
    }
    return data;
  }

  clone(): CreateRoleDto {
    const json = this.toJSON();
    let result = new CreateRoleDto();
    result.init(json);
    return result;
  }
}

export interface ICreateRoleDto {
  name: string;
  displayName: string;
  normalizedName: string | undefined;
  description: string | undefined;
  isStatic: boolean | undefined;
  permissions: string[] | undefined;
}

export class RoleDto implements IRoleDto {
  name: string;
  displayName: string;
  normalizedName: string | undefined;
  description: string | undefined;
  isStatic: boolean | undefined;
  permissions: string[] | undefined;
  id: number | undefined;

  constructor(data?: IRoleDto) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(data?: any) {
    if (data) {
      this.name = data["name"];
      this.displayName = data["displayName"];
      this.normalizedName = data["normalizedName"];
      this.description = data["description"];
      this.isStatic = data["isStatic"];
      if (data["permissions"] && data["permissions"].constructor === Array) {
        this.permissions = [];
        for (let item of data["permissions"])
          this.permissions.push(item);
      }
      this.id = data["id"];
    }
  }

  static fromJS(data: any): RoleDto {
    data = typeof data === 'object' ? data : {};
    let result = new RoleDto();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data["name"] = this.name;
    data["displayName"] = this.displayName;
    data["normalizedName"] = this.normalizedName;
    data["description"] = this.description;
    data["isStatic"] = this.isStatic;
    if (this.permissions && this.permissions.constructor === Array) {
      data["permissions"] = [];
      for (let item of this.permissions)
        data["permissions"].push(item);
    }
    data["id"] = this.id;
    return data;
  }

  clone(): RoleDto {
    const json = this.toJSON();
    let result = new RoleDto();
    result.init(json);
    return result;
  }
}

export interface IRoleDto {
  name: string;
  displayName: string;
  normalizedName: string | undefined;
  description: string | undefined;
  isStatic: boolean | undefined;
  permissions: string[] | undefined;
  id: number | undefined;
}

export class ListResultDtoOfPermissionDto implements IListResultDtoOfPermissionDto {
  items: PermissionDto[] | undefined;

  constructor(data?: IListResultDtoOfPermissionDto) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(data?: any) {
    if (data) {
      if (data["items"] && data["items"].constructor === Array) {
        this.items = [];
        for (let item of data["items"])
          this.items.push(PermissionDto.fromJS(item));
      }
    }
  }

  static fromJS(data: any): ListResultDtoOfPermissionDto {
    data = typeof data === 'object' ? data : {};
    let result = new ListResultDtoOfPermissionDto();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    if (this.items && this.items.constructor === Array) {
      data["items"] = [];
      for (let item of this.items)
        data["items"].push(item.toJSON());
    }
    return data;
  }

  clone(): ListResultDtoOfPermissionDto {
    const json = this.toJSON();
    let result = new ListResultDtoOfPermissionDto();
    result.init(json);
    return result;
  }
}

export interface IListResultDtoOfPermissionDto {
  items: PermissionDto[] | undefined;
}

export class PermissionDto implements IPermissionDto {
  name: string | undefined;
  displayName: string | undefined;
  description: string | undefined;
  id: number | undefined;

  constructor(data?: IPermissionDto) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(data?: any) {
    if (data) {
      this.name = data["name"];
      this.displayName = data["displayName"];
      this.description = data["description"];
      this.id = data["id"];
    }
  }

  static fromJS(data: any): PermissionDto {
    data = typeof data === 'object' ? data : {};
    let result = new PermissionDto();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data["name"] = this.name;
    data["displayName"] = this.displayName;
    data["description"] = this.description;
    data["id"] = this.id;
    return data;
  }

  clone(): PermissionDto {
    const json = this.toJSON();
    let result = new PermissionDto();
    result.init(json);
    return result;
  }
}

export interface IPermissionDto {
  name: string | undefined;
  displayName: string | undefined;
  description: string | undefined;
  id: number | undefined;
}

export class GetRoleForEditOutput implements IGetRoleForEditOutput {
  role: RoleEditDto | undefined;
  permissions: FlatPermissionDto[] | undefined;
  grantedPermissionNames: string[] | undefined;

  constructor(data?: IGetRoleForEditOutput) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(data?: any) {
    if (data) {
      this.role = data["role"] ? RoleEditDto.fromJS(data["role"]) : <any>undefined;
      if (data["permissions"] && data["permissions"].constructor === Array) {
        this.permissions = [];
        for (let item of data["permissions"])
          this.permissions.push(FlatPermissionDto.fromJS(item));
      }
      if (data["grantedPermissionNames"] && data["grantedPermissionNames"].constructor === Array) {
        this.grantedPermissionNames = [];
        for (let item of data["grantedPermissionNames"])
          this.grantedPermissionNames.push(item);
      }
    }
  }

  static fromJS(data: any): GetRoleForEditOutput {
    data = typeof data === 'object' ? data : {};
    let result = new GetRoleForEditOutput();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data["role"] = this.role ? this.role.toJSON() : <any>undefined;
    if (this.permissions && this.permissions.constructor === Array) {
      data["permissions"] = [];
      for (let item of this.permissions)
        data["permissions"].push(item.toJSON());
    }
    if (this.grantedPermissionNames && this.grantedPermissionNames.constructor === Array) {
      data["grantedPermissionNames"] = [];
      for (let item of this.grantedPermissionNames)
        data["grantedPermissionNames"].push(item);
    }
    return data;
  }

  clone(): GetRoleForEditOutput {
    const json = this.toJSON();
    let result = new GetRoleForEditOutput();
    result.init(json);
    return result;
  }
}

export interface IGetRoleForEditOutput {
  role: RoleEditDto | undefined;
  permissions: FlatPermissionDto[] | undefined;
  grantedPermissionNames: string[] | undefined;
}

export class RoleEditDto implements IRoleEditDto {
  name: string;
  displayName: string;
  description: string | undefined;
  isStatic: boolean | undefined;
  id: number | undefined;

  constructor(data?: IRoleEditDto) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(data?: any) {
    if (data) {
      this.name = data["name"];
      this.displayName = data["displayName"];
      this.description = data["description"];
      this.isStatic = data["isStatic"];
      this.id = data["id"];
    }
  }

  static fromJS(data: any): RoleEditDto {
    data = typeof data === 'object' ? data : {};
    let result = new RoleEditDto();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data["name"] = this.name;
    data["displayName"] = this.displayName;
    data["description"] = this.description;
    data["isStatic"] = this.isStatic;
    data["id"] = this.id;
    return data;
  }

  clone(): RoleEditDto {
    const json = this.toJSON();
    let result = new RoleEditDto();
    result.init(json);
    return result;
  }
}

export interface IRoleEditDto {
  name: string;
  displayName: string;
  description: string | undefined;
  isStatic: boolean | undefined;
  id: number | undefined;
}

export class FlatPermissionDto implements IFlatPermissionDto {
  name: string | undefined;
  displayName: string | undefined;
  description: string | undefined;

  constructor(data?: IFlatPermissionDto) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(data?: any) {
    if (data) {
      this.name = data["name"];
      this.displayName = data["displayName"];
      this.description = data["description"];
    }
  }

  static fromJS(data: any): FlatPermissionDto {
    data = typeof data === 'object' ? data : {};
    let result = new FlatPermissionDto();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data["name"] = this.name;
    data["displayName"] = this.displayName;
    data["description"] = this.description;
    return data;
  }

  clone(): FlatPermissionDto {
    const json = this.toJSON();
    let result = new FlatPermissionDto();
    result.init(json);
    return result;
  }
}

export interface IFlatPermissionDto {
  name: string | undefined;
  displayName: string | undefined;
  description: string | undefined;
}

export class PagedResultDtoOfRoleDto implements IPagedResultDtoOfRoleDto {
  totalCount: number | undefined;
  items: RoleDto[] | undefined;

  constructor(data?: IPagedResultDtoOfRoleDto) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(data?: any) {
    if (data) {
      this.totalCount = data["totalCount"];
      if (data["items"] && data["items"].constructor === Array) {
        this.items = [];
        for (let item of data["items"])
          this.items.push(RoleDto.fromJS(item));
      }
    }
  }

  static fromJS(data: any): PagedResultDtoOfRoleDto {
    data = typeof data === 'object' ? data : {};
    let result = new PagedResultDtoOfRoleDto();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data["totalCount"] = this.totalCount;
    if (this.items && this.items.constructor === Array) {
      data["items"] = [];
      for (let item of this.items)
        data["items"].push(item.toJSON());
    }
    return data;
  }

  clone(): PagedResultDtoOfRoleDto {
    const json = this.toJSON();
    let result = new PagedResultDtoOfRoleDto();
    result.init(json);
    return result;
  }
}

export interface IPagedResultDtoOfRoleDto {
  totalCount: number | undefined;
  items: RoleDto[] | undefined;
}

export class GetCurrentLoginInformationsOutput implements IGetCurrentLoginInformationsOutput {
  application: ApplicationInfoDto | undefined;
  user: UserLoginInfoDto | undefined;
  tenant: TenantLoginInfoDto | undefined;

  constructor(data?: IGetCurrentLoginInformationsOutput) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(data?: any) {
    if (data) {
      this.application = data["application"] ? ApplicationInfoDto.fromJS(data["application"]) : <any>undefined;
      this.user = data["user"] ? UserLoginInfoDto.fromJS(data["user"]) : <any>undefined;
      this.tenant = data["tenant"] ? TenantLoginInfoDto.fromJS(data["tenant"]) : <any>undefined;
    }
  }

  static fromJS(data: any): GetCurrentLoginInformationsOutput {
    data = typeof data === 'object' ? data : {};
    let result = new GetCurrentLoginInformationsOutput();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data["application"] = this.application ? this.application.toJSON() : <any>undefined;
    data["user"] = this.user ? this.user.toJSON() : <any>undefined;
    data["tenant"] = this.tenant ? this.tenant.toJSON() : <any>undefined;
    return data;
  }

  clone(): GetCurrentLoginInformationsOutput {
    const json = this.toJSON();
    let result = new GetCurrentLoginInformationsOutput();
    result.init(json);
    return result;
  }
}

export interface IGetCurrentLoginInformationsOutput {
  application: ApplicationInfoDto | undefined;
  user: UserLoginInfoDto | undefined;
  tenant: TenantLoginInfoDto | undefined;
}

export class ApplicationInfoDto implements IApplicationInfoDto {
  version: string | undefined;
  releaseDate: moment.Moment | undefined;
  features: { [key: string] : boolean; } | undefined;

  constructor(data?: IApplicationInfoDto) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(data?: any) {
    if (data) {
      this.version = data["version"];
      this.releaseDate = data["releaseDate"] ? moment(data["releaseDate"].toString()) : <any>undefined;
      if (data["features"]) {
        this.features = {};
        for (let key in data["features"]) {
          if (data["features"].hasOwnProperty(key))
            this.features[key] = data["features"][key];
        }
      }
    }
  }

  static fromJS(data: any): ApplicationInfoDto {
    data = typeof data === 'object' ? data : {};
    let result = new ApplicationInfoDto();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data["version"] = this.version;
    data["releaseDate"] = this.releaseDate ? this.releaseDate.toISOString() : <any>undefined;
    if (this.features) {
      data["features"] = {};
      for (let key in this.features) {
        if (this.features.hasOwnProperty(key))
          data["features"][key] = this.features[key];
      }
    }
    return data;
  }

  clone(): ApplicationInfoDto {
    const json = this.toJSON();
    let result = new ApplicationInfoDto();
    result.init(json);
    return result;
  }
}

export interface IApplicationInfoDto {
  version: string | undefined;
  releaseDate: moment.Moment | undefined;
  features: { [key: string] : boolean; } | undefined;
}

export class UserLoginInfoDto implements IUserLoginInfoDto {
  name: string | undefined;
  surname: string | undefined;
  userName: string | undefined;
  emailAddress: string | undefined;
  id: number | undefined;

  constructor(data?: IUserLoginInfoDto) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(data?: any) {
    if (data) {
      this.name = data["name"];
      this.surname = data["surname"];
      this.userName = data["userName"];
      this.emailAddress = data["emailAddress"];
      this.id = data["id"];
    }
  }

  static fromJS(data: any): UserLoginInfoDto {
    data = typeof data === 'object' ? data : {};
    let result = new UserLoginInfoDto();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data["name"] = this.name;
    data["surname"] = this.surname;
    data["userName"] = this.userName;
    data["emailAddress"] = this.emailAddress;
    data["id"] = this.id;
    return data;
  }

  clone(): UserLoginInfoDto {
    const json = this.toJSON();
    let result = new UserLoginInfoDto();
    result.init(json);
    return result;
  }
}

export interface IUserLoginInfoDto {
  name: string | undefined;
  surname: string | undefined;
  userName: string | undefined;
  emailAddress: string | undefined;
  id: number | undefined;
}

export class TenantLoginInfoDto implements ITenantLoginInfoDto {
  tenancyName: string | undefined;
  name: string | undefined;
  id: number | undefined;

  constructor(data?: ITenantLoginInfoDto) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(data?: any) {
    if (data) {
      this.tenancyName = data["tenancyName"];
      this.name = data["name"];
      this.id = data["id"];
    }
  }

  static fromJS(data: any): TenantLoginInfoDto {
    data = typeof data === 'object' ? data : {};
    let result = new TenantLoginInfoDto();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data["tenancyName"] = this.tenancyName;
    data["name"] = this.name;
    data["id"] = this.id;
    return data;
  }

  clone(): TenantLoginInfoDto {
    const json = this.toJSON();
    let result = new TenantLoginInfoDto();
    result.init(json);
    return result;
  }
}

export interface ITenantLoginInfoDto {
  tenancyName: string | undefined;
  name: string | undefined;
  id: number | undefined;
}

export class CreateTenantDto implements ICreateTenantDto {
  tenancyName: string;
  name: string;
  adminEmailAddress: string;
  connectionString: string | undefined;
  isActive: boolean | undefined;

  constructor(data?: ICreateTenantDto) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(data?: any) {
    if (data) {
      this.tenancyName = data["tenancyName"];
      this.name = data["name"];
      this.adminEmailAddress = data["adminEmailAddress"];
      this.connectionString = data["connectionString"];
      this.isActive = data["isActive"];
    }
  }

  static fromJS(data: any): CreateTenantDto {
    data = typeof data === 'object' ? data : {};
    let result = new CreateTenantDto();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data["tenancyName"] = this.tenancyName;
    data["name"] = this.name;
    data["adminEmailAddress"] = this.adminEmailAddress;
    data["connectionString"] = this.connectionString;
    data["isActive"] = this.isActive;
    return data;
  }

  clone(): CreateTenantDto {
    const json = this.toJSON();
    let result = new CreateTenantDto();
    result.init(json);
    return result;
  }
}

export interface ICreateTenantDto {
  tenancyName: string;
  name: string;
  adminEmailAddress: string;
  connectionString: string | undefined;
  isActive: boolean | undefined;
}

export class TenantDto implements ITenantDto {
  tenancyName: string;
  name: string;
  isActive: boolean | undefined;
  id: number | undefined;

  constructor(data?: ITenantDto) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(data?: any) {
    if (data) {
      this.tenancyName = data["tenancyName"];
      this.name = data["name"];
      this.isActive = data["isActive"];
      this.id = data["id"];
    }
  }

  static fromJS(data: any): TenantDto {
    data = typeof data === 'object' ? data : {};
    let result = new TenantDto();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data["tenancyName"] = this.tenancyName;
    data["name"] = this.name;
    data["isActive"] = this.isActive;
    data["id"] = this.id;
    return data;
  }

  clone(): TenantDto {
    const json = this.toJSON();
    let result = new TenantDto();
    result.init(json);
    return result;
  }
}

export interface ITenantDto {
  tenancyName: string;
  name: string;
  isActive: boolean | undefined;
  id: number | undefined;
}

export class PagedResultDtoOfTenantDto implements IPagedResultDtoOfTenantDto {
  totalCount: number | undefined;
  items: TenantDto[] | undefined;

  constructor(data?: IPagedResultDtoOfTenantDto) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(data?: any) {
    if (data) {
      this.totalCount = data["totalCount"];
      if (data["items"] && data["items"].constructor === Array) {
        this.items = [];
        for (let item of data["items"])
          this.items.push(TenantDto.fromJS(item));
      }
    }
  }

  static fromJS(data: any): PagedResultDtoOfTenantDto {
    data = typeof data === 'object' ? data : {};
    let result = new PagedResultDtoOfTenantDto();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data["totalCount"] = this.totalCount;
    if (this.items && this.items.constructor === Array) {
      data["items"] = [];
      for (let item of this.items)
        data["items"].push(item.toJSON());
    }
    return data;
  }

  clone(): PagedResultDtoOfTenantDto {
    const json = this.toJSON();
    let result = new PagedResultDtoOfTenantDto();
    result.init(json);
    return result;
  }
}

export interface IPagedResultDtoOfTenantDto {
  totalCount: number | undefined;
  items: TenantDto[] | undefined;
}

export class AuthenticateModel implements IAuthenticateModel {
  userNameOrEmailAddress: string;
  password: string;
  rememberClient: boolean | undefined;

  constructor(data?: IAuthenticateModel) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(data?: any) {
    if (data) {
      this.userNameOrEmailAddress = data["userNameOrEmailAddress"];
      this.password = data["password"];
      this.rememberClient = data["rememberClient"];
    }
  }

  static fromJS(data: any): AuthenticateModel {
    data = typeof data === 'object' ? data : {};
    let result = new AuthenticateModel();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data["userNameOrEmailAddress"] = this.userNameOrEmailAddress;
    data["password"] = this.password;
    data["rememberClient"] = this.rememberClient;
    return data;
  }

  clone(): AuthenticateModel {
    const json = this.toJSON();
    let result = new AuthenticateModel();
    result.init(json);
    return result;
  }
}

export interface IAuthenticateModel {
  userNameOrEmailAddress: string;
  password: string;
  rememberClient: boolean | undefined;
}

export class AuthenticateResultModel implements IAuthenticateResultModel {
  accessToken: string | undefined;
  encryptedAccessToken: string | undefined;
  expireInSeconds: number | undefined;
  userId: number | undefined;

  constructor(data?: IAuthenticateResultModel) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(data?: any) {
    if (data) {
      this.accessToken = data["accessToken"];
      this.encryptedAccessToken = data["encryptedAccessToken"];
      this.expireInSeconds = data["expireInSeconds"];
      this.userId = data["userId"];
    }
  }

  static fromJS(data: any): AuthenticateResultModel {
    data = typeof data === 'object' ? data : {};
    let result = new AuthenticateResultModel();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data["accessToken"] = this.accessToken;
    data["encryptedAccessToken"] = this.encryptedAccessToken;
    data["expireInSeconds"] = this.expireInSeconds;
    data["userId"] = this.userId;
    return data;
  }

  clone(): AuthenticateResultModel {
    const json = this.toJSON();
    let result = new AuthenticateResultModel();
    result.init(json);
    return result;
  }
}

export interface IAuthenticateResultModel {
  accessToken: string | undefined;
  encryptedAccessToken: string | undefined;
  expireInSeconds: number | undefined;
  userId: number | undefined;
}

export class ExternalLoginProviderInfoModel implements IExternalLoginProviderInfoModel {
  name: string | undefined;
  clientId: string | undefined;

  constructor(data?: IExternalLoginProviderInfoModel) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(data?: any) {
    if (data) {
      this.name = data["name"];
      this.clientId = data["clientId"];
    }
  }

  static fromJS(data: any): ExternalLoginProviderInfoModel {
    data = typeof data === 'object' ? data : {};
    let result = new ExternalLoginProviderInfoModel();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data["name"] = this.name;
    data["clientId"] = this.clientId;
    return data;
  }

  clone(): ExternalLoginProviderInfoModel {
    const json = this.toJSON();
    let result = new ExternalLoginProviderInfoModel();
    result.init(json);
    return result;
  }
}

export interface IExternalLoginProviderInfoModel {
  name: string | undefined;
  clientId: string | undefined;
}

export class ExternalAuthenticateModel implements IExternalAuthenticateModel {
  authProvider: string;
  providerKey: string;
  providerAccessCode: string;

  constructor(data?: IExternalAuthenticateModel) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(data?: any) {
    if (data) {
      this.authProvider = data["authProvider"];
      this.providerKey = data["providerKey"];
      this.providerAccessCode = data["providerAccessCode"];
    }
  }

  static fromJS(data: any): ExternalAuthenticateModel {
    data = typeof data === 'object' ? data : {};
    let result = new ExternalAuthenticateModel();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data["authProvider"] = this.authProvider;
    data["providerKey"] = this.providerKey;
    data["providerAccessCode"] = this.providerAccessCode;
    return data;
  }

  clone(): ExternalAuthenticateModel {
    const json = this.toJSON();
    let result = new ExternalAuthenticateModel();
    result.init(json);
    return result;
  }
}

export interface IExternalAuthenticateModel {
  authProvider: string;
  providerKey: string;
  providerAccessCode: string;
}

export class ExternalAuthenticateResultModel implements IExternalAuthenticateResultModel {
  accessToken: string | undefined;
  encryptedAccessToken: string | undefined;
  expireInSeconds: number | undefined;
  waitingForActivation: boolean | undefined;

  constructor(data?: IExternalAuthenticateResultModel) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(data?: any) {
    if (data) {
      this.accessToken = data["accessToken"];
      this.encryptedAccessToken = data["encryptedAccessToken"];
      this.expireInSeconds = data["expireInSeconds"];
      this.waitingForActivation = data["waitingForActivation"];
    }
  }

  static fromJS(data: any): ExternalAuthenticateResultModel {
    data = typeof data === 'object' ? data : {};
    let result = new ExternalAuthenticateResultModel();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data["accessToken"] = this.accessToken;
    data["encryptedAccessToken"] = this.encryptedAccessToken;
    data["expireInSeconds"] = this.expireInSeconds;
    data["waitingForActivation"] = this.waitingForActivation;
    return data;
  }

  clone(): ExternalAuthenticateResultModel {
    const json = this.toJSON();
    let result = new ExternalAuthenticateResultModel();
    result.init(json);
    return result;
  }
}

export interface IExternalAuthenticateResultModel {
  accessToken: string | undefined;
  encryptedAccessToken: string | undefined;
  expireInSeconds: number | undefined;
  waitingForActivation: boolean | undefined;
}

export class CreateUserDto implements ICreateUserDto {
  userName: string;
  name: string;
  surname: string;
  emailAddress: string;
  isActive: boolean | undefined;
  roleNames: string[] | undefined;
  password: string;

  constructor(data?: ICreateUserDto) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(data?: any) {
    if (data) {
      this.userName = data["userName"];
      this.name = data["name"];
      this.surname = data["surname"];
      this.emailAddress = data["emailAddress"];
      this.isActive = data["isActive"];
      if (data["roleNames"] && data["roleNames"].constructor === Array) {
        this.roleNames = [];
        for (let item of data["roleNames"])
          this.roleNames.push(item);
      }
      this.password = data["password"];
    }
  }

  static fromJS(data: any): CreateUserDto {
    data = typeof data === 'object' ? data : {};
    let result = new CreateUserDto();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data["userName"] = this.userName;
    data["name"] = this.name;
    data["surname"] = this.surname;
    data["emailAddress"] = this.emailAddress;
    data["isActive"] = this.isActive;
    if (this.roleNames && this.roleNames.constructor === Array) {
      data["roleNames"] = [];
      for (let item of this.roleNames)
        data["roleNames"].push(item);
    }
    data["password"] = this.password;
    return data;
  }

  clone(): CreateUserDto {
    const json = this.toJSON();
    let result = new CreateUserDto();
    result.init(json);
    return result;
  }
}

export interface ICreateUserDto {
  userName: string;
  name: string;
  surname: string;
  emailAddress: string;
  isActive: boolean | undefined;
  roleNames: string[] | undefined;
  password: string;
}

export class UserDto implements IUserDto {
  userName: string;
  name: string;
  surname: string;
  emailAddress: string;
  isActive: boolean | undefined;
  fullName: string | undefined;
  lastLoginTime: moment.Moment | undefined;
  creationTime: moment.Moment | undefined;
  roleNames: string[] | undefined;
  id: number | undefined;

  constructor(data?: IUserDto) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(data?: any) {
    if (data) {
      this.userName = data["userName"];
      this.name = data["name"];
      this.surname = data["surname"];
      this.emailAddress = data["emailAddress"];
      this.isActive = data["isActive"];
      this.fullName = data["fullName"];
      this.lastLoginTime = data["lastLoginTime"] ? moment(data["lastLoginTime"].toString()) : <any>undefined;
      this.creationTime = data["creationTime"] ? moment(data["creationTime"].toString()) : <any>undefined;
      if (data["roleNames"] && data["roleNames"].constructor === Array) {
        this.roleNames = [];
        for (let item of data["roleNames"])
          this.roleNames.push(item);
      }
      this.id = data["id"];
    }
  }

  static fromJS(data: any): UserDto {
    data = typeof data === 'object' ? data : {};
    let result = new UserDto();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data["userName"] = this.userName;
    data["name"] = this.name;
    data["surname"] = this.surname;
    data["emailAddress"] = this.emailAddress;
    data["isActive"] = this.isActive;
    data["fullName"] = this.fullName;
    data["lastLoginTime"] = this.lastLoginTime ? this.lastLoginTime.toISOString() : <any>undefined;
    data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
    if (this.roleNames && this.roleNames.constructor === Array) {
      data["roleNames"] = [];
      for (let item of this.roleNames)
        data["roleNames"].push(item);
    }
    data["id"] = this.id;
    return data;
  }

  clone(): UserDto {
    const json = this.toJSON();
    let result = new UserDto();
    result.init(json);
    return result;
  }
}

export interface IUserDto {
  userName: string;
  name: string;
  surname: string;
  emailAddress: string;
  isActive: boolean | undefined;
  fullName: string | undefined;
  lastLoginTime: moment.Moment | undefined;
  creationTime: moment.Moment | undefined;
  roleNames: string[] | undefined;
  id: number | undefined;
}

export class ListResultDtoOfRoleDto implements IListResultDtoOfRoleDto {
  items: RoleDto[] | undefined;

  constructor(data?: IListResultDtoOfRoleDto) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(data?: any) {
    if (data) {
      if (data["items"] && data["items"].constructor === Array) {
        this.items = [];
        for (let item of data["items"])
          this.items.push(RoleDto.fromJS(item));
      }
    }
  }

  static fromJS(data: any): ListResultDtoOfRoleDto {
    data = typeof data === 'object' ? data : {};
    let result = new ListResultDtoOfRoleDto();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    if (this.items && this.items.constructor === Array) {
      data["items"] = [];
      for (let item of this.items)
        data["items"].push(item.toJSON());
    }
    return data;
  }

  clone(): ListResultDtoOfRoleDto {
    const json = this.toJSON();
    let result = new ListResultDtoOfRoleDto();
    result.init(json);
    return result;
  }
}

export interface IListResultDtoOfRoleDto {
  items: RoleDto[] | undefined;
}

export class ChangeUserLanguageDto implements IChangeUserLanguageDto {
  languageName: string;

  constructor(data?: IChangeUserLanguageDto) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(data?: any) {
    if (data) {
      this.languageName = data["languageName"];
    }
  }

  static fromJS(data: any): ChangeUserLanguageDto {
    data = typeof data === 'object' ? data : {};
    let result = new ChangeUserLanguageDto();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data["languageName"] = this.languageName;
    return data;
  }

  clone(): ChangeUserLanguageDto {
    const json = this.toJSON();
    let result = new ChangeUserLanguageDto();
    result.init(json);
    return result;
  }
}

export interface IChangeUserLanguageDto {
  languageName: string;
}

export class PagedResultDtoOfUserDto implements IPagedResultDtoOfUserDto {
  totalCount: number | undefined;
  items: UserDto[] | undefined;

  constructor(data?: IPagedResultDtoOfUserDto) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(data?: any) {
    if (data) {
      this.totalCount = data["totalCount"];
      if (data["items"] && data["items"].constructor === Array) {
        this.items = [];
        for (let item of data["items"])
          this.items.push(UserDto.fromJS(item));
      }
    }
  }

  static fromJS(data: any): PagedResultDtoOfUserDto {
    data = typeof data === 'object' ? data : {};
    let result = new PagedResultDtoOfUserDto();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data["totalCount"] = this.totalCount;
    if (this.items && this.items.constructor === Array) {
      data["items"] = [];
      for (let item of this.items)
        data["items"].push(item.toJSON());
    }
    return data;
  }

  clone(): PagedResultDtoOfUserDto {
    const json = this.toJSON();
    let result = new PagedResultDtoOfUserDto();
    result.init(json);
    return result;
  }
}

export interface IPagedResultDtoOfUserDto {
  totalCount: number | undefined;
  items: UserDto[] | undefined;
}

export enum IsTenantAvailableOutputState {
  _1 = 1,
  _2 = 2,
  _3 = 3,
}

export class SwaggerException extends Error {
  message: string;
  status: number;
  response: string;
  headers: { [key: string]: any; };
  result: any;

  constructor(message: string, status: number, response: string, headers: { [key: string]: any; }, result: any) {
    super();

    this.message = message;
    this.status = status;
    this.response = response;
    this.headers = headers;
    this.result = result;
  }

  protected isSwaggerException = true;

  static isSwaggerException(obj: any): obj is SwaggerException {
    return obj.isSwaggerException === true;
  }
}

function throwException(message: string, status: number, response: string, headers: { [key: string]: any; }, result?: any): Observable<any> {
  if(result !== null && result !== undefined)
    return _observableThrow(result);
  else
    return _observableThrow(new SwaggerException(message, status, response, headers, null));
}

function blobToText(blob: any): Observable<string> {
  return new Observable<string>((observer: any) => {
    if (!blob) {
      observer.next("");
      observer.complete();
    } else {
      let reader = new FileReader();
      reader.onload = function() {
        observer.next(this.result);
        observer.complete();
      }
      reader.readAsText(blob);
    }
  });
}
